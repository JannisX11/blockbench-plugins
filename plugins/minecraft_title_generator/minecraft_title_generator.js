(async () => {
  const repo = "ewanhowell5195/MinecraftTitleGenerator"
  const thumbnail = "data:image/webp;base64,UklGRlgAAABXRUJQVlA4TEsAAAAvX8AKEBcw//M///MfgAe2jSQp2iSPOr+nSXPHOng7ov8TUKa/ZLlkuWT5VVyOy1FKKXNFRBwtJ0mU3YktcTmu31JKKVPklPlPZXoA"
  const fonts = {
    "minecraft-ten": {
      name: "Minecraft Ten",
      thumbnail,
      characters: {"0":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[0,5.4,0.448,7.4],"south":[0.448,5.4,0,7.4],"up":[0.448,5.4,0,4.3],"down":[0.448,8.5,0,7.4]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"1":[{"from":[-2,2,-3],"to":[18,42,19],"faces":{"north":[0.48,5.4,0.8,7.4],"south":[0.8,5.4,0.48,7.4],"up":[0.8,5.4,0.48,4.3],"down":[0.8,8.5,0.48,7.4]}},{"from":[12,44,21],"to":[-4,0,-5],"faces":{"north":[0.016,13.35,0,13.3],"east":[0.016,13.35,0,13.3],"south":[0.016,13.35,0,13.3],"west":[0.528,14.2,0.544,13.65],"up":[0.016,13.35,0,13.3],"down":[0.016,13.35,0,13.3]}},{"from":[20,40,21],"to":[12,28,-5],"faces":{"north":[0.016,13.35,0,13.3],"south":[0.016,13.35,0,13.3],"west":[0.016,13.35,0,13.3],"up":[0.016,13.35,0,13.3],"down":[0.016,13.35,0,13.3]}}],"2":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[0.832,5.4,1.28,7.4],"south":[1.28,5.4,0.832,7.4],"up":[1.28,5.4,0.832,4.3],"down":[1.28,8.5,0.832,7.4]}},{"from":[8,28,-5],"to":[24,32,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,12,-5],"to":[8,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.032,13.85,0,14.4],"east":[0.016,13.85,0.032,14.4],"south":[0,13.85,0.032,14.4],"west":[0,13.85,0.016,14.4],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"3":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[1.312,5.4,1.76,7.4],"south":[1.76,5.4,1.312,7.4],"up":[1.76,5.4,1.312,4.3],"down":[1.76,8.5,1.312,7.4]}},{"from":[8,28,-5],"to":[24,32,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[8,12,-5],"to":[24,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.08,13.3,0.048,13.85],"east":[0.016,13.3,0,13.35],"south":[0.048,13.3,0.08,13.85],"west":[0.064,13.3,0.048,13.85],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"4":[{"from":[-10,2,-3],"to":[26,42,19],"faces":{"north":[1.792,5.4,2.368,7.4],"south":[2.368,5.4,1.792,7.4],"up":[2.368,5.4,1.792,4.3],"down":[2.368,8.5,1.792,7.4]}},{"from":[-12,20,-5],"to":[-8,44,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-12,0,-5],"to":[-8,8,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[8,0,-5],"to":[28,8,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,20,-5],"to":[28,28,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,28,-5],"to":[24,36,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[16,36,-5],"to":[20,40,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[8,40,-5],"to":[16,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[28,44,21],"to":[-12,0,-5],"faces":{"north":[0.704,14.4,0.544,13.85],"east":[0.544,14.4,0.56,13.85],"south":[0.544,14.4,0.704,13.85],"west":[0.544,14.4,0.56,13.85],"up":[0.544,13.9,0.704,13.85],"down":[0.544,13.9,0.704,13.85]}}],"5":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[2.4,5.4,2.848,7.4],"south":[2.848,5.4,2.4,7.4],"up":[2.848,5.4,2.4,4.3],"down":[2.848,8.5,2.4,7.4]}},{"from":[8,12,-5],"to":[24,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,28,-5],"to":[8,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.85,0.032,14.4],"east":[0,13.85,0.016,14.4],"south":[0.032,13.85,0,14.4],"west":[0.016,13.85,0.032,14.4],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"6":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[2.88,5.4,3.328,7.4],"south":[3.328,5.4,2.88,7.4],"up":[3.328,5.4,2.88,4.3],"down":[3.328,8.5,2.88,7.4]}},{"from":[-8,28,-5],"to":[8,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.512,14.4,0.544,13.85],"east":[0.512,14.4,0.528,13.85],"south":[0.544,14.4,0.512,13.85],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"7":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[3.36,5.4,3.808,7.4],"south":[3.808,5.4,3.36,7.4],"up":[3.808,5.4,3.36,4.3],"down":[3.808,8.5,3.36,7.4]}},{"from":[0,0,-5],"to":[4,8,21],"faces":{"east":[0.016,13.3,0,13.35],"up":[0.016,13.3,0,13.35]}},{"from":[-4,8,-5],"to":[0,16,21],"faces":{"east":[0.016,13.3,0,13.35],"up":[0.016,13.3,0,13.35]}},{"from":[-8,16,-5],"to":[-4,24,21],"faces":{"east":[0.016,13.3,0,13.35],"up":[0.016,13.3,0,13.35]}},{"from":[8,28,-5],"to":[24,32,21],"faces":{"west":[0.016,13.3,0,13.35],"up":[0.016,13.3,0,13.35]}},{"from":[20,12,21],"to":[16,0,-5],"faces":{"west":[0.016,13.3,0,13.35],"down":[0.016,13.3,0,13.35]}},{"from":[16,20,21],"to":[12,12,-5],"faces":{"west":[0.016,13.3,0,13.35],"down":[0.016,13.3,0,13.35]}},{"from":[12,28,21],"to":[8,20,-5],"faces":{"west":[0.016,13.3,0,13.35],"down":[0.016,13.3,0,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.752,13.85,0.624,13.3],"east":[0.752,13.85,0.736,13.3],"south":[0.624,13.85,0.752,13.3],"west":[0.64,13.85,0.624,13.3],"up":[0.624,13.85,0.752,13.8],"down":[0.016,13.3,0,13.35]}}],"8":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[3.84,5.4,4.288,7.4],"south":[4.288,5.4,3.84,7.4],"up":[4.288,5.4,3.84,4.3],"down":[4.288,8.5,3.84,7.4]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"9":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[4.32,5.4,4.768,7.4],"south":[4.768,5.4,4.32,7.4],"up":[4.768,5.4,4.32,4.3],"down":[4.768,8.5,4.32,7.4]}},{"from":[8,12,-5],"to":[24,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.544,13.85,0.512,14.4],"east":[0,13.3,0.016,13.35],"south":[0.512,13.85,0.544,14.4],"west":[0.512,13.85,0.528,14.4],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"!":[{"from":[2,2,-3],"to":[14,42,19],"faces":{"north":[10.144,5.4,10.336,7.4],"south":[10.144,5.4,10.336,7.4],"up":[10.336,5.4,10.144,4.3],"down":[10.336,8.5,10.144,7.4]}},{"from":[16,44,21],"to":[0,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"#":[{"from":[-10,2,-3],"to":[26,42,19],"faces":{"north":[5.344,5.4,5.92,7.4],"south":[5.92,5.4,5.344,7.4],"up":[5.92,5.4,5.344,4.3],"down":[5.92,8.5,5.344,7.4]}},{"from":[28,36,21],"to":[24,24,-5],"faces":{"north":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[28,20,21],"to":[24,8,-5],"faces":{"north":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,20,21],"to":[-12,8,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,36,21],"to":[-12,24,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0.704,13.85,0.72,14.4],"south":[0,13.3,0.016,13.35],"west":[0.704,13.85,0.72,14.4],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"$":[{"from":[-6,-2,-3],"to":[22,42,19],"faces":{"north":[0.928,9.7,1.376,11.9],"south":[1.376,9.7,0.928,11.9],"up":[1.376,9.7,0.928,8.6],"down":[1.376,13.2,0.928,12.1]}},{"from":[24,38,21],"to":[-8,2,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0.016,13.3,0,13.35],"west":[0,13.3,0.016,13.35],"up":[1.232,14.3,1.488,14.35],"down":[1.232,14.3,1.488,14.35]}},{"from":[14,2,21],"to":[2,-4,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[14,44,21],"to":[2,38,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"%":[{"from":[-10,2,-3],"to":[26,42,19],"faces":{"north":[13.344,5.4,13.92,7.4],"south":[13.92,5.4,13.344,7.4],"up":[13.92,5.4,13.344,4.3],"down":[13.92,8.5,13.344,7.4]}},{"from":[20,16,-5],"to":[28,24,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[12,24,-5],"to":[28,28,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0.016,13.35,0.048,13.4]}},{"from":[4,36,-5],"to":[12,44,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[4,0,-5],"to":[12,8,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-12,16,-5],"to":[4,20,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0.048,13.35,0.016,13.4],"down":[0,13.3,0.016,13.35]}},{"from":[-12,20,-5],"to":[-4,28,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[28,44,21],"to":[-12,0,-5],"faces":{"north":[1.024,13.85,1.104,14.4],"east":[1.024,13.85,1.04,14.4],"south":[1.104,13.85,1.024,14.4],"west":[1.088,13.85,1.104,14.4],"up":[1.024,14.35,1.104,14.4],"down":[1.024,13.85,1.104,13.9]}}],"&":[{"from":[-8,2,-3],"to":[24,42,19],"faces":{"north":[4.8,5.4,5.312,7.4],"south":[5.312,5.4,4.8,7.4],"up":[5.312,5.4,4.8,4.3],"down":[5.312,8.5,4.8,7.4]}},{"from":[-6,24,-5],"to":[-2,28,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-6,24,21],"to":[-10,16,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-6,12,21],"to":[-10,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[26,44,21],"to":[-6,0,-5],"faces":{"north":[0.736,14.4,0.864,13.85],"east":[0.72,14.4,0.736,13.85],"south":[0.864,14.4,0.736,13.85],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"'":[{"from":[2,22,-3],"to":[14,42,19],"faces":{"north":[11.328,5.4,11.52,6.4],"south":[11.52,5.4,11.328,6.4],"up":[11.52,5.4,11.328,4.3],"down":[11.52,8.5,11.328,7.4]}},{"from":[12,20,-5],"to":[16,28,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[16,44,21],"to":[0,20,-5],"faces":{"north":[0.096,13.6,0.16,13.9],"east":[0,13.3,0.016,13.35],"south":[0.16,13.6,0.096,13.9],"west":[0.032,13.6,0.016,13.9],"up":[0.144,13.3,0.08,13.35],"down":[0,13.3,0.016,13.35]}}],"(":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[5.952,5.4,6.4,7.4],"south":[6.4,5.4,5.952,7.4],"up":[6.4,5.4,5.952,4.3],"down":[6.4,8.5,5.952,7.4]}},{"from":[16,36,-5],"to":[24,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,12,-5],"to":[0,20,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[16,0,-5],"to":[24,8,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-8,24,-5],"to":[0,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[0,20,-5],"to":[8,24,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.816,13.3,0.752,13.85],"east":[0.8,13.3,0.816,13.85],"south":[0.752,13.3,0.816,13.85],"west":[0.752,13.3,0.768,13.85],"up":[0.752,13.3,0.816,13.35],"down":[0.752,13.3,0.816,13.35]}}],")":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[6.432,5.4,6.88,7.4],"south":[6.88,5.4,6.432,7.4],"up":[6.88,5.4,6.432,4.3],"down":[6.88,8.5,6.432,7.4]}},{"from":[8,20,-5],"to":[16,24,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,36,-5],"to":[0,44,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[16,12,-5],"to":[24,20,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,0,-5],"to":[0,8,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[16,24,-5],"to":[24,32,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.752,13.3,0.816,13.85],"east":[0.752,13.3,0.768,13.85],"south":[0.816,13.3,0.752,13.85],"west":[0.8,13.3,0.816,13.85],"up":[0.816,13.3,0.752,13.35],"down":[0.816,13.3,0.752,13.35]}}],"+":[{"from":[-4,10,-3],"to":[20,34,19],"faces":{"north":[11.552,5.8,11.936,7],"south":[11.936,5.8,11.552,7],"up":[11.936,5.4,11.552,4.3],"down":[11.936,8.5,11.552,7.4]}},{"from":[14,28,-5],"to":[22,36,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-6,28,-5],"to":[2,36,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-6,8,-5],"to":[2,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[14,8,-5],"to":[22,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[22,36,21],"to":[-6,8,-5],"faces":{"north":[0.96,13.3,1.072,13.65],"east":[1.056,13.3,1.072,13.65],"south":[0.96,13.3,1.072,13.65],"west":[0.96,13.3,0.976,13.65],"up":[0.96,13.6,1.072,13.65],"down":[0.96,13.3,1.072,13.35]}}],",":[{"from":[2,-6,-3],"to":[14,14,19],"faces":{"north":[0,11.1,0.192,12.1],"south":[0.192,11.1,0,12.1],"up":[0.192,9.7,0,8.6],"down":[0.192,13.2,0,12.1]}},{"from":[12,-8,-5],"to":[16,0,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[16,16,21],"to":[0,-8,-5],"faces":{"north":[0.096,13.6,0.16,13.9],"east":[0,13.3,0.016,13.35],"south":[0.16,13.6,0.096,13.9],"west":[0.032,13.6,0.016,13.9],"up":[0.144,13.3,0.08,13.35],"down":[0,13.3,0.016,13.35]}}],"-":[{"from":[0,18,-3],"to":[16,26,19],"faces":{"north":[10.816,6.2,11.072,6.6],"south":[11.072,6.2,10.816,6.6],"up":[11.072,5.4,10.816,4.3],"down":[11.072,8.5,10.816,7.4]}},{"from":[18,28,21],"to":[-2,16,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],".":[{"from":[2,2,-3],"to":[14,14,19],"faces":{"north":[10.368,6.8,10.56,7.4],"south":[10.56,6.8,10.368,7.4],"up":[10.56,5.4,10.368,4.3],"down":[10.56,8.5,10.368,7.4]}},{"from":[16,16,21],"to":[0,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],";":[{"from":[16,36,21],"to":[0,20,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[2,-6,-3],"to":[14,34,19],"faces":{"north":[0.224,10.1,0.416,12.1],"south":[0.416,10.1,0.224,12.1],"up":[0.416,9.7,0.224,8.6],"down":[0.416,13.2,0.224,12.1]}},{"from":[12,-8,-5],"to":[16,0,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[16,16,21],"to":[0,-8,-5],"faces":{"north":[0.096,13.6,0.16,13.9],"east":[0,13.3,0.016,13.35],"south":[0.16,13.6,0.096,13.9],"west":[0.032,13.6,0.016,13.9],"up":[0.144,13.3,0.08,13.35],"down":[0,13.3,0.016,13.35]}}],"=":[{"from":[-4,10,-3],"to":[20,34,19],"faces":{"north":[11.968,5.8,12.352,7],"south":[12.352,5.8,11.968,7],"up":[12.352,5.4,11.968,4.3],"down":[12.352,8.5,11.968,7.4]}},{"from":[-6,20,-5],"to":[22,24,21],"faces":{"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[22,36,21],"to":[-6,8,-5],"faces":{"north":[0.736,13.9,0.752,14.25],"east":[0.736,13.9,0.752,14.25],"south":[0.736,13.9,0.752,14.25],"west":[0.736,13.9,0.752,14.25],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"@":[{"from":[-14,-6,-3],"to":[30,42,19],"faces":{"north":[1.408,9.7,2.112,12.1],"south":[2.112,9.7,1.408,12.1],"up":[2.112,9.7,1.408,8.6],"down":[2.112,13.2,1.408,12.1]}},{"from":[28,40,-5],"to":[32,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[0,30,-5],"to":[16,32,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[0,16,-5],"to":[4,18,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[28,-8,-5],"to":[32,-4,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-16,40,-5],"to":[-12,44,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[32,44,21],"to":[-16,4,-5],"faces":{"north":[1.68,14.3,1.296,13.3],"east":[1.68,14.3,1.664,13.3],"south":[1.296,14.3,1.68,13.3],"west":[1.312,14.3,1.296,13.3],"up":[1.632,14.3,1.44,14.35],"down":[1.68,13.35,1.296,13.3]}},{"from":[32,4,21],"to":[-4,-8,-5],"faces":{"north":[1.824,13.45,1.68,13.3],"east":[0,13.3,0.016,13.35],"south":[1.68,13.45,1.824,13.3],"west":[1.68,13.45,1.696,13.3],"up":[1.68,13.4,1.824,13.45]}}],"a":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[0.48,1.1,0.928,3.1],"south":[0.928,1.1,0.48,3.1],"up":[0.928,1.1,0.48,0],"down":[0.928,4.2,0.48,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"*":[{"from":[-4,18,-3],"to":[20,42,19],"faces":{"north":[14.304,5.4,14.688,6.6],"south":[14.688,5.4,14.304,6.6],"up":[14.688,5.4,14.304,4.3],"down":[14.688,8.5,14.304,7.4]}},{"from":[6,40,-5],"to":[10,44,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[6,16,-5],"to":[10,20,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[18,28,-5],"to":[22,32,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-6,28,-5],"to":[-2,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[22,44,21],"to":[-6,16,-5],"faces":{"north":[1.072,13.65,1.184,13.3],"east":[1.168,13.65,1.184,13.3],"south":[1.072,13.65,1.184,13.3],"west":[1.072,13.65,1.088,13.3],"up":[1.072,13.65,1.184,13.6],"down":[1.072,13.35,1.184,13.3]}}],"b":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[0.96,1.1,1.408,3.1],"south":[1.408,1.1,0.96,3.1],"up":[1.408,1.1,0.96,0],"down":[1.408,4.2,0.96,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"\\":[{"from":[-10,2,-3],"to":[26,42,19],"faces":{"north":[9.056,5.4,9.632,7.4],"south":[9.632,5.4,9.056,7.4],"up":[9.632,5.4,9.056,4.3],"down":[9.632,8.5,9.056,7.4]}},{"from":[4,36,-5],"to":[12,44,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-4,24,-5],"to":[4,36,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-12,16,-5],"to":[-4,24,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,20,-5],"to":[28,28,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[12,8,-5],"to":[20,20,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[4,0,-5],"to":[12,8,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[28,44,21],"to":[-12,0,-5],"faces":{"north":[0.96,13.85,0.88,14.4],"east":[0.944,13.85,0.96,14.4],"south":[0.88,13.85,0.96,14.4],"west":[0.88,13.85,0.896,14.4],"up":[0.88,13.85,0.96,13.9],"down":[0.88,14.35,0.96,14.4]}}],"c":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[1.44,1.1,1.888,3.1],"south":[1.888,1.1,1.44,3.1],"up":[1.888,1.1,1.44,0],"down":[1.888,4.2,1.44,3.1]}},{"from":[-8,12,-5],"to":[8,32,21],"faces":{"east":[0.016,13.3,0,13.35],"up":[0.016,13.3,0,13.35],"down":[0.016,13.3,0,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.032,13.3,0,13.85],"east":[0.032,13.3,0.016,13.85],"south":[0,13.3,0.032,13.85],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],":":[{"from":[16,36,21],"to":[0,20,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[2,2,-3],"to":[14,34,19],"faces":{"north":[10.592,5.8,10.784,7.4],"south":[10.784,5.8,10.592,7.4],"up":[10.784,5.4,10.592,4.3],"down":[10.784,8.5,10.592,7.4]}},{"from":[16,16,21],"to":[0,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"ðŸ˜³":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[0,1.1,0.448,3.1],"south":[0.448,1.1,0,3.1],"up":[0.448,1.1,0,0],"down":[0.448,4.2,0,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"d":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[1.92,1.1,2.368,3.1],"south":[2.368,1.1,1.92,3.1],"up":[2.368,1.1,1.92,0],"down":[2.368,4.2,1.92,3.1]}},{"from":[-4,40,21],"to":[-8,4,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-4,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0.032,13.3,0.048,13.85],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"e":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[2.4,1.1,2.848,3.1],"south":[2.848,1.1,2.4,3.1],"up":[2.848,1.1,2.4,0],"down":[2.848,4.2,2.4,3.1]}},{"from":[-8,28,-5],"to":[8,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,12,-5],"to":[8,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.048,13.3,0.08,13.85],"east":[0.064,13.3,0.048,13.85],"south":[0.08,13.3,0.048,13.85],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"â”£":[{"from":[0,10,-3],"to":[16,34,19],"faces":{"north":[15.424,5.8,15.68,7],"south":[15.68,5.8,15.424,7],"up":[15.68,5.4,15.424,4.3],"down":[15.68,8.5,15.424,7.4]}},{"from":[-2,28,-5],"to":[6,36,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-2,8,-5],"to":[6,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[18,36,21],"to":[-2,8,-5],"faces":{"north":[0.96,13.3,1.04,13.65],"east":[1.056,13.3,1.072,13.65],"south":[0.992,13.3,1.072,13.65],"west":[0,13.3,0.016,13.35],"up":[0.992,13.6,1.072,13.65],"down":[0.992,13.3,1.072,13.35]}}],"f":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[2.88,1.1,3.328,3.1],"south":[3.328,1.1,2.88,3.1],"up":[3.328,1.1,2.88,0],"down":[3.328,4.2,2.88,3.1]}},{"from":[-8,28,-5],"to":[8,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,0,-5],"to":[8,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.096,13.85,0.064,13.3],"east":[0.096,13.85,0.08,13.3],"south":[0.064,13.85,0.096,13.3],"west":[0,13.3,0.016,13.35],"up":[0.016,13.35,0.048,13.4],"down":[0,13.3,0.016,13.35]}}],"/":[{"from":[-10,2,-3],"to":[26,42,19],"faces":{"north":[8.448,5.4,9.024,7.4],"south":[9.024,5.4,8.448,7.4],"up":[9.024,5.4,8.448,4.3],"down":[9.024,8.5,8.448,7.4]}},{"from":[20,16,-5],"to":[28,24,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[12,24,-5],"to":[20,36,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[4,36,-5],"to":[12,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[4,0,-5],"to":[12,8,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-4,8,-5],"to":[4,20,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-12,20,-5],"to":[-4,28,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[28,44,21],"to":[-12,0,-5],"faces":{"north":[0.88,13.85,0.96,14.4],"east":[0.88,13.85,0.896,14.4],"south":[0.96,13.85,0.88,14.4],"west":[0.944,13.85,0.96,14.4],"up":[0.88,14.35,0.96,14.4],"down":[0.88,13.85,0.96,13.9]}}],"g":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[3.36,1.1,3.808,3.1],"south":[3.808,1.1,3.36,3.1],"up":[3.808,1.1,3.36,0],"down":[3.808,4.2,3.36,3.1]}},{"from":[-8,28,-5],"to":[8,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.096,13.85,0.128,13.3],"east":[0.112,13.85,0.096,13.3],"south":[0.128,13.85,0.096,13.3],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],">":[{"from":[-6,8,-3],"to":[22,36,19],"faces":{"north":[12.864,5.7,13.312,7.1],"south":[13.312,5.7,12.864,7.1],"up":[13.312,5.4,12.864,4.3],"down":[13.312,8.5,12.864,7.4]}},{"from":[16,18,-5],"to":[24,26,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[0,34,-5],"to":[8,38,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,30,-5],"to":[0,34,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[0,6,-5],"to":[8,10,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-8,10,-5],"to":[0,14,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,38,21],"to":[-8,6,-5],"faces":{"north":[0.96,13.65,1.024,14.05],"east":[0.96,13.65,0.976,14.05],"south":[1.024,13.65,0.96,14.05],"west":[1.008,13.65,1.024,14.05],"up":[1.024,14,0.96,14.05],"down":[1.024,13.65,0.96,13.7]}}],"h":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[3.84,1.1,4.288,3.1],"south":[4.288,1.1,3.84,3.1],"up":[4.288,1.1,3.84,0],"down":[4.288,4.2,3.84,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"i":[{"from":[2,2,-3],"to":[14,42,19],"faces":{"north":[4.32,1.1,4.512,3.1],"south":[4.512,1.1,4.32,3.1],"up":[4.512,1.1,4.32,0],"down":[4.512,4.2,4.32,3.1]}},{"from":[16,44,21],"to":[0,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"j":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[4.544,1.1,4.992,3.1],"south":[4.992,1.1,4.544,3.1],"up":[4.992,1.1,4.544,0],"down":[4.992,4.2,4.544,3.1]}},{"from":[8,20,-5],"to":[24,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.112,13.85,0.144,13.3],"east":[0,13.3,0.016,13.35],"south":[0.144,13.85,0.112,13.3],"west":[0.128,13.85,0.144,13.3],"up":[0,13.3,0.016,13.35],"down":[0.032,13.35,0.064,13.4]}}],"k":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[5.024,1.1,5.472,3.1],"south":[5.472,1.1,5.024,3.1],"up":[5.472,1.1,5.024,0],"down":[5.472,4.2,5.024,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"l":[{"from":[-4,2,-3],"to":[20,42,19],"faces":{"north":[5.504,1.1,5.888,3.1],"south":[5.888,1.1,5.504,3.1],"up":[5.888,1.1,5.504,0],"down":[5.888,4.2,5.504,3.1]}},{"from":[-6,12,-5],"to":[6,44,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[22,44,21],"to":[-6,0,-5],"faces":{"north":[0.144,13.85,0.256,13.3],"east":[0.144,13.85,0.16,13.3],"south":[0.256,13.85,0.144,13.3],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0.256,13.3,0.144,13.35]}}],"<":[{"from":[-6,8,-3],"to":[22,36,19],"faces":{"north":[12.384,5.7,12.832,7.1],"south":[12.832,5.7,12.384,7.1],"up":[12.832,5.4,12.384,4.3],"down":[12.832,8.5,12.384,7.4]}},{"from":[-8,18,-5],"to":[0,26,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[8,34,-5],"to":[16,38,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[16,30,-5],"to":[24,34,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[8,6,-5],"to":[16,10,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[16,10,-5],"to":[24,14,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,38,21],"to":[-8,6,-5],"faces":{"north":[1.024,13.65,0.96,14.05],"east":[1.008,13.65,1.024,14.05],"south":[0.96,13.65,1.024,14.05],"west":[0.96,13.65,0.976,14.05],"up":[0.96,14,1.024,14.05],"down":[0.96,13.65,1.024,13.7]}}],"m":[{"from":[-12,2,-3],"to":[28,42,19],"faces":{"north":[5.92,1.1,6.56,3.1],"east":[0.032,13.4,0.048,13.3],"south":[6.56,1.1,5.92,3.1],"west":[0.032,13.4,0.048,13.3],"up":[6.56,1.1,5.92,0],"down":[6.56,4.2,5.92,3.1]}},{"from":[4,10,-3],"to":[12,10,19],"faces":{"down":[6.72,4.2,6.592,3.1]}},{"from":[2,36,-5],"to":[14,44,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"down":[0.016,13.35,0.064,13.4]}},{"from":[6,28,-5],"to":[10,36,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[2,0,-5],"to":[14,8,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[30,44,21],"to":[-14,0,-5],"faces":{"north":[0.192,13.85,0.368,13.3],"east":[0,13.3,0.016,13.35],"south":[0.192,13.85,0.368,13.3],"west":[0,13.3,0.016,13.35],"up":[0.192,13.3,0.368,13.35],"down":[0.192,13.3,0.368,13.35]}}],"n":[{"from":[-8,2,-3],"to":[24,42,19],"faces":{"north":[6.752,1.1,7.264,3.1],"south":[7.264,1.1,6.752,3.1],"up":[7.264,1.1,6.752,0],"down":[7.264,4.2,6.752,3.1]}},{"from":[6,36,-5],"to":[10,44,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[6,0,-5],"to":[10,10,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[26,44,21],"to":[-10,0,-5],"faces":{"north":[0.304,14.4,0.448,13.3],"east":[0,13.3,0.016,13.35],"south":[0.304,14.4,0.448,13.3],"west":[0,13.3,0.016,13.35],"up":[0.304,13.3,0.448,13.35],"down":[0.304,13.3,0.448,13.35]}}],"o":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[7.296,1.1,7.744,3.1],"south":[7.744,1.1,7.296,3.1],"up":[7.744,1.1,7.296,0],"down":[7.744,4.2,7.296,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"ðŸ˜©":[{"from":[2,22,-3],"to":[14,42,19],"faces":{"north":[11.104,5.4,11.296,6.4],"south":[11.296,5.4,11.104,6.4],"up":[11.296,5.4,11.104,4.3],"down":[11.296,8.5,11.104,7.4]}},{"from":[0,36,-5],"to":[4,44,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[16,44,21],"to":[0,20,-5],"faces":{"north":[0.16,13.9,0.096,13.6],"east":[0.032,13.9,0.016,13.6],"south":[0.096,13.9,0.16,13.6],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0.08,13.3,0.144,13.35]}}],"p":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[7.776,1.1,8.224,3.1],"south":[8.224,1.1,7.776,3.1],"up":[8.224,1.1,7.776,0],"down":[8.224,4.2,7.776,3.1]}},{"from":[-8,0,-5],"to":[8,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.288,14.4,0.32,13.85],"east":[0.288,14.4,0.304,13.85],"south":[0.32,14.4,0.288,13.85],"west":[0,13.3,0.016,13.35],"up":[0.016,13.35,0.048,13.4],"down":[0,13.3,0.016,13.35]}}],"q":[{"from":[-8,2,-3],"to":[24,42,19],"faces":{"north":[8.256,1.1,8.768,3.1],"south":[8.768,1.1,8.256,3.1],"up":[8.768,1.1,8.256,0],"down":[8.768,4.2,8.256,3.1]}},{"from":[-6,12,21],"to":[-10,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[26,44,21],"to":[-6,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0.368,14.3,0.384,13.75],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"?":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[9.664,5.4,10.112,7.4],"south":[10.112,5.4,9.664,7.4],"up":[10.112,5.4,9.664,4.3],"down":[10.112,8.5,9.664,7.4]}},{"from":[16,0,-5],"to":[24,28,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-8,0,-5],"to":[0,20,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.96,13.85,0.896,13.3],"east":[0.96,13.85,0.944,13.3],"south":[0.896,13.85,0.96,13.3],"west":[0.912,13.85,0.896,13.3],"up":[0.96,13.85,0.896,13.8],"down":[0,13.3,0.016,13.35]}}],"r":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[8.8,1.1,9.248,3.1],"south":[9.248,1.1,8.8,3.1],"up":[9.248,1.1,8.8,0],"down":[9.248,4.2,8.8,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"s":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[9.28,1.1,9.728,3.1],"south":[9.728,1.1,9.28,3.1],"up":[9.728,1.1,9.28,0],"down":[9.728,4.2,9.28,3.1]}},{"from":[8,12,-5],"to":[24,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,28,-5],"to":[8,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.85,0.032,14.4],"east":[0,13.85,0.016,14.4],"south":[0.032,13.85,0,14.4],"west":[0.016,13.85,0.032,14.4],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"â”«":[{"from":[0,10,-3],"to":[16,34,19],"faces":{"north":[15.136,5.8,15.392,7],"south":[15.392,5.8,15.136,7],"up":[15.392,5.4,15.136,4.3],"down":[15.392,8.5,15.136,7.4]}},{"from":[10,28,-5],"to":[18,36,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[10,8,-5],"to":[18,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[18,36,21],"to":[-2,8,-5],"faces":{"north":[0.992,13.3,1.072,13.65],"east":[0,13.3,0.016,13.35],"south":[0.96,13.3,1.04,13.65],"west":[1.056,13.3,1.072,13.65],"up":[0.96,13.6,1.04,13.65],"down":[0.96,13.3,1.04,13.35]}}],"t":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[9.76,1.1,10.208,3.1],"south":[10.208,1.1,9.76,3.1],"up":[10.208,1.1,9.76,0],"down":[10.208,4.2,9.76,3.1]}},{"from":[16,0,-5],"to":[24,32,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-8,0,-5],"to":[0,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.032,14.4,0.096,13.85],"east":[0.032,14.4,0.048,13.85],"south":[0.032,14.4,0.096,13.85],"west":[0.032,14.4,0.048,13.85],"up":[0.032,14.4,0.096,14.35],"down":[0,13.3,0.016,13.35]}}],"u":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[10.24,1.1,10.688,3.1],"south":[10.688,1.1,10.24,3.1],"up":[10.688,1.1,10.24,0],"down":[10.688,4.2,10.24,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"v":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[10.72,1.1,11.168,3.1],"south":[11.168,1.1,10.72,3.1],"up":[11.168,1.1,10.72,0],"down":[11.168,4.2,10.72,3.1]}},{"from":[-8,8,-5],"to":[-4,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-4,0,-5],"to":[0,8,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[16,0,-5],"to":[20,8,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[20,8,-5],"to":[24,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.096,14.4,0.224,13.85],"east":[0.096,14.4,0.112,13.85],"south":[0.096,14.4,0.224,13.85],"west":[0.096,14.4,0.112,13.85],"up":[0.096,14.35,0.224,14.4],"down":[0,13.3,0.016,13.35]}}],"w":[{"from":[-12,2,-3],"to":[28,42,19],"faces":{"north":[11.2,1.1,11.84,3.1],"east":[0.032,13.3,0.048,13.4],"south":[11.84,1.1,11.2,3.1],"west":[0.032,13.3,0.048,13.4],"up":[11.84,1.1,11.2,0],"down":[11.84,4.2,11.2,3.1]}},{"from":[4,30,-3],"to":[12,30,19],"faces":{"up":[12,1.1,11.872,0]}},{"from":[2,32,-5],"to":[14,44,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[6,0,-5],"to":[10,12,21],"faces":{"east":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[26,0,-5],"to":[30,8,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-14,0,-5],"to":[-10,8,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[30,44,21],"to":[-14,0,-5],"faces":{"north":[0.448,13.85,0.624,13.3],"east":[0.448,13.85,0.464,13.3],"south":[0.448,13.85,0.624,13.3],"west":[0.448,13.85,0.464,13.3],"up":[0.448,13.85,0.624,13.8],"down":[0.448,13.35,0.624,13.3]}}],"x":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[12.032,1.1,12.48,3.1],"south":[12.48,1.1,12.032,3.1],"up":[12.48,1.1,12.032,0],"down":[12.48,4.2,12.032,3.1]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"y":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[12.512,1.1,12.96,3.1],"south":[12.96,1.1,12.512,3.1],"up":[12.96,1.1,12.512,0],"down":[12.96,4.2,12.512,3.1]}},{"from":[-8,0,-5],"to":[0,20,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[16,0,-5],"to":[24,20,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.224,14.4,0.288,13.85],"east":[0.224,14.4,0.24,13.85],"south":[0.224,14.4,0.288,13.85],"west":[0.224,14.4,0.24,13.85],"up":[0.224,14.35,0.288,14.4],"down":[0,13.3,0.016,13.35]}}],"z":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[12.992,1.1,13.44,3.1],"south":[13.44,1.1,12.992,3.1],"up":[13.44,1.1,12.992,0],"down":[13.44,4.2,12.992,3.1]}},{"from":[-8,12,-5],"to":[8,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0.048,13.35,0.016,13.4],"down":[0,13.3,0.016,13.35]}},{"from":[8,28,-5],"to":[24,32,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0.016,13.35,0.048,13.4]}},{"from":[16,24,-5],"to":[24,28,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,16,-5],"to":[0,20,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-8,0,-5],"faces":{"north":[0.448,13.85,0.512,14.4],"east":[0.464,13.85,0.448,14.4],"south":[0.512,13.85,0.448,14.4],"west":[0.448,14.4,0.464,13.85],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"[":[{"from":[-2,2,-3],"to":[18,42,19],"faces":{"north":[6.912,5.4,7.232,7.4],"south":[7.232,5.4,6.912,7.4],"up":[7.232,5.4,6.912,4.3],"down":[7.232,8.5,6.912,7.4]}},{"from":[-4,12,-5],"to":[4,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,44,21],"to":[-4,0,-5],"faces":{"north":[0.88,13.85,0.832,14.4],"east":[0.016,13.3,0.032,13.85],"south":[0.832,13.85,0.88,14.4],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"]":[{"from":[-2,2,-3],"to":[18,42,19],"faces":{"north":[7.264,5.4,7.584,7.4],"south":[7.584,5.4,7.264,7.4],"up":[7.584,5.4,7.264,4.3],"down":[7.584,8.5,7.264,7.4]}},{"from":[12,12,-5],"to":[20,32,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,44,21],"to":[-4,0,-5],"faces":{"north":[0.832,13.85,0.88,14.4],"east":[0,13.3,0.016,13.35],"south":[0.88,13.85,0.832,14.4],"west":[0.016,13.3,0.032,13.85],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"^":[{"from":[-2,30,-3],"to":[18,42,19],"faces":{"north":[13.952,5.4,14.272,6],"south":[14.272,5.4,13.952,6],"up":[14.272,5.4,13.952,4.3],"down":[14.272,8.5,13.952,7.4]}},{"from":[16,40,-5],"to":[20,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-4,40,-5],"to":[0,44,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,44,21],"to":[-4,28,-5],"faces":{"north":[1.024,13.85,1.12,13.65],"east":[1.104,13.85,1.12,13.65],"south":[1.024,13.85,1.12,13.65],"west":[1.024,13.85,1.04,13.65],"up":[0,13.3,0.016,13.35],"down":[1.024,13.7,1.12,13.65]}}],"_":[{"from":[-6,-6,-3],"to":[22,2,19],"faces":{"north":[0.448,11.7,0.896,12.1],"south":[0.896,11.7,0.448,12.1],"up":[0.896,9.7,0.448,8.6],"down":[0.896,13.2,0.448,12.1]}},{"from":[24,4,21],"to":[-8,-8,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"{":[{"from":[-4,2,-3],"to":[20,42,19],"faces":{"north":[7.616,5.4,8,7.4],"south":[8,5.4,7.616,7.4],"up":[8,5.4,7.616,4.3],"down":[8,8.5,7.616,7.4]}},{"from":[-6,12,-5],"to":[2,20,21],"faces":{"east":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-6,24,-5],"to":[2,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[2,20,-5],"to":[6,24,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[22,28,21],"to":[18,16,-5],"faces":{"north":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[18,44,21],"to":[-6,0,-5],"faces":{"north":[0.8,13.3,0.896,13.85],"east":[0.8,13.3,0.816,13.85],"south":[0.896,13.3,0.8,13.85],"west":[0.528,13.5,0.544,14.05],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"}":[{"from":[-4,2,-3],"to":[20,42,19],"faces":{"north":[8.032,5.4,8.416,7.4],"south":[8.416,5.4,8.032,7.4],"up":[8.416,5.4,8.032,4.3],"down":[8.416,8.5,8.032,7.4]}},{"from":[14,12,-5],"to":[22,20,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[14,24,-5],"to":[22,32,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[10,20,-5],"to":[14,24,21],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-2,28,21],"to":[-6,16,-5],"rotation":{"angle":0,"axis":"y","origin":[16,0,0]},"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[22,44,21],"to":[-2,0,-5],"faces":{"north":[0.896,13.3,0.8,13.85],"east":[0.528,13.5,0.544,14.05],"south":[0.8,13.3,0.896,13.85],"west":[0.8,13.3,0.816,13.85],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}}],"~":[{"from":[-4,30,-3],"to":[20,42,19],"faces":{"north":[14.72,5.4,15.104,6],"south":[15.104,5.4,14.72,6],"up":[15.104,5.4,14.72,4.3],"down":[15.104,8.5,14.72,7.4]}},{"from":[18,40,-5],"to":[22,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-6,28,-5],"to":[-2,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[22,44,21],"to":[-6,28,-5],"faces":{"north":[1.68,13.45,1.792,13.65],"east":[1.776,13.65,1.792,13.45],"south":[1.68,13.45,1.792,13.65],"west":[1.68,13.65,1.696,13.45],"up":[1.68,13.65,1.792,13.6],"down":[1.68,13.5,1.792,13.45]}}],"Â£":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[13.472,1.1,13.92,3.1],"south":[13.92,1.1,13.472,3.1],"up":[13.92,1.1,13.472,0],"down":[13.92,4.2,13.472,3.1]}},{"from":[16,40,-5],"to":[20,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,28,-5],"to":[24,40,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,12,-5],"to":[24,16,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-4,28,-5],"to":[4,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-4,12,-5],"to":[4,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-4,12,21],"to":[-8,0,-5],"faces":{"north":[0,13.3,0.016,13.35],"east":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,44,21],"to":[-4,0,-5],"faces":{"north":[1.216,14.4,1.104,13.85],"east":[0.08,13.85,0.096,13.3],"south":[1.104,14.4,1.216,13.85],"west":[1.104,14.4,1.12,13.85],"up":[0,13.3,0.016,13.35],"down":[1.104,13.9,1.216,13.85]}}],"â‚¬":[{"from":[-6,2,-3],"to":[22,42,19],"faces":{"north":[13.952,1.1,14.4,3.1],"south":[14.4,1.1,13.952,3.1],"up":[14.4,1.1,13.952,0],"down":[14.4,4.2,13.952,3.1]}},{"from":[16,40,-5],"to":[20,44,21],"faces":{"west":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[16,0,-5],"to":[20,4,21],"faces":{"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35]}},{"from":[-8,28,-5],"to":[4,32,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[-8,12,-5],"to":[4,16,21],"faces":{"east":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[24,28,21],"to":[20,16,-5],"faces":{"north":[0,13.3,0.016,13.35],"south":[0,13.3,0.016,13.35],"west":[0,13.3,0.016,13.35],"up":[0,13.3,0.016,13.35],"down":[0,13.3,0.016,13.35]}},{"from":[20,44,21],"to":[-8,0,-5],"faces":{"north":[1.296,13.85,1.184,13.3],"east":[1.28,13.85,1.296,13.3],"south":[1.184,13.85,1.296,13.3],"west":[1.216,14.4,1.232,13.85],"up":[1.184,13.85,1.296,13.8],"down":[1.184,13.35,1.296,13.3]}}]},
      textures: {
        flat: {
          name: "Flat",
          thumbnail,
          texture: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+gAAAFABAMAAADdXUt9AAAAD1BMVEUAAAAAAABUVFSwsLD///9xh7SGAAAAAXRSTlMAQObYZgAABt5JREFUeF7s0bEJwDAQA0DtlP13S2WCcGHyaVKcKgv8hbhclXlNJrdJ15Xzp6dU6/dg1Pcde91Wne8q67jnr+R1fooOHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4d+s2+HKwgCQRSFB+jBBHz/Z4oFpA4Jl9FarM4Fogtqs33/Bqx+VuR4PfaoKtYt+aJHQeP3xiSnz5EnRgv3IYB6cRNd9BDRRRdd9Hb9ILroKI8quuiI6KKLLvoyPqtu3TMEuFDPowOX6JTo1Dga9T6EzjvSn3l9dNFFF1100UVHvhgdomE/Mgd9sA/yn0YXXXTRl1Fuf4suOoIa4LpbDCSi1wjREaL3f5roPDSS0LckdNLtoQeGLaAXXXTRRRdd9HVN6CPz0ZEeetVhdOQMehgyPBVVdNFFF70X0PwbuuizNnL7EC0e0lIso4fB6MjrMjq9TqK/MO1W0UUXXXTRRafFBdFZ++hVl0F/ZibbJHTRRRdddNFFR47UxkKgtdDpv+yQB2u+TJiWLCiASuit9zHeiy666KKLLrroVfPQRa/6cXTRRRdddNHv7NFBCsAgDATAvKX/f2RpSRGpJHiV2YuGiAYn9nO9+dZfmenLiHV3PJSpHmoOFddnNXdytzNY/wdPxrbqzsV64KhvLUfInI0OHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4cuInKzd8c4AAIhEAD//2s7dLNylZUZG7MhQMI84Nbn2aNSsSbUqA9jrIn9ry17Ze3IL+qna62/ydMz7TXnvPaOferHxIghOekX6NChQ4cOHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4cOHTp06NChQ4cOHTp06Bd7d5CDMAhEYbiH8/5ncmNC4Mk8MpSC8Z+NEgbo9HNh0Ibw2E1zjnUJmUGmurN59Q7O+jok6AlGaEXSJyVKhiTfd5xWkWnfNGt9GhJ/hg466KCDDvqwQwF/Eh10RdLGmeiggw66kq5ABx10mc8fid0oB4lBaa4pVrFZ32P4IkcWEB/h6SD27pxHl9qqz1Tva1zJ3owOOuigm2VXoIMO+uXwtIaF6CUeRPdFGHRpz6ArgwJqz0nooIMOui9kKTrooPv9Eh05vpvjNnakbFlu0CNW8sq9ARG69pqdkwn0YFZx2I8OOuigayHnoIMO+nVl0H3yq4kH0N2MwwO+G2TRo4wa4Xx00EEHXdd4BB100N1NlZAMndn9J2LzDy4ePR/ZzZnsFeQ3Z0AHHfR8ZH9wuRMddNBBrxCUKiqifplH1x5B+kV00EEHPbjvOXTQQd/0AGNFnticWfywgxObRr/zYYdc7EcHHXTQ/cqggw466KCDDjrooIP+Zu+OcQCEYRgA9v+vZqtCTJQd3UQb5CJ6D/DQx74W5mft/hqoybWOf0jnKRmZ36zz5ZqGZXtEOf8rGn/fv/E97TLnlGXd3FGd/gYdOnTo0KFDhw4dOnTo0KFDhw4dOnTo0KFDhw4dOnTo0KFDhw4dOnTo0KFDhw79Ye8OjQCAQSAI0n/VaMigEIjs6ndXwMd3gOHwvT+1l/W7QXRER3RER3RER3RER3RER3RE3xMd0REd0REd0REd0e+JnuzYIQ5DMQxEwRyu9z9Ti1zpLwnsuvNIHBA0xMrZmF6fZo5OU4Iu6IIOfaZV7IKuVN6BLuh4r9DjkaALuqALuqD/StAf1zgFXdAFvTSLHHToexJ06NChF37OCLqgC7o2oQs6z1v0CTr0/qCPLnTo0KELuqALemfQBb0+6NlAt6ELuhJ17L8luhUOuqALemXQI+jQBf0Pgv5mj45RAABhIAj6lvz/kQoiqF26BGaaK67c0RWxnInH9W//j+iIjuiIjuiIjuiIjuiIjuiIjuhZoiM6oiM6oiM6olcl+my/XnIjhoEYiJI3IO9/2SAtjO0Y+WxjTT0I7d4XDEH6rwAAbSu1cjO7+ykdalzXbdzlteqxUP8ZfWwYnejpEf1PeXZ0RPEZfWTCq0vmyLfoei7ErdSrqCu6+zNth+iOXFeNt4xO9KhXceuu8o3rLo0kH+tjIco30XNEdyPd73Q9Gur0KutMY6+P1LFbdKJrZW5avTo73TE62l+jZ6J7q+joneTmeLqljqf7ztGJ7l6it86sW0cnetu4a7rtl+jx86MjTk+qz+hytaJr4z+dJ5vndDWWI6mz7hqd6GOip23VSN41OtFnpm06tIYkZ7vo8FSN4wmuDq8hacM7Hb1GP6hDUsdu0YmuVmd0yU2OuHUXSW+Vm+h6MwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ANfHFiVIRSXVwAAAABJRU5ErkJggg=="
        }
      },
      overlays: {
        none: {
          name: "None",
          thumbnail: "data:image/webp;base64,UklGRlgAAABXRUJQVlA4TEsAAAAvX8AKEBcw//M//wMUgAe2jSQp2iSPOr+nSXPHOng7ov8TUKa/ZLlkuWT5VVyOy1FKKXNFRBwtJ0mU3YktcTmu31JKKVPklPlPZXoA"
        }
      },
      faces: [
        [22, 62],
        [108, 148],
        [194, 194, 234, 242]
      ],
      ends: [
        [0, 22, 62, 84],
        [86, 108, 148, 170],
        [172, 194, 242, 264]
      ],
      height: 44,
      border: 266,
      terminatorSpace: true
    }
  }
  const fontData = []
  let tileables = {
    cobblestone: {
      texture: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAElBMVEW1tbWmpqaIh4hubW1hYWFSUlLm8qFQAAAAcUlEQVR42gVAARGDMAz8MAMjh4CSLwIWIgDSIGAD/1p2iPk5pTfFOW3QLR3nGrrGQxSLTL1wp2TJ3PF6W/yaOjSV9eEB2y3a4omQPSerG4f6biMXkP0a8X2DMdpytQkuIWuY49CuziJmclhoIcsjUvgH41gVHD61kt4AAAAASUVORK5CYII="
    }
  }
  const connection = {
    roots: [
      `https://raw.githubusercontent.com/${repo}/main`,
      `https://cdn.jsdelivr.net/gh/${repo}`
    ],
    rootIndex: 0
  }
  let root = connection.roots[0]
  let format, action, dialog, mode, panel, styles, preview, debug
  const id = "minecraft_title_generator"
  const name = "Minecraft Title Generator"
  const icon = "text_fields"
  const description = "Create Minecraft-styled title models!"
  const links = {
    website: {
      text: "By Ewan Howell",
      link: "https://ewanhowell.com/",
      icon: "language",
      colour: "#33E38E"
    },
    discord: {
      text: "Discord Server",
      link: "https://discord.ewanhowell.com/",
      icon: "fab.fa-discord",
      colour: "#727FFF"
    },
    github: {
      text: "Submit Textures and Fonts",
      link: `https://github.com/${repo}/`,
      icon: "fab.fa-github",
      colour: "#6E40C9"
    },
    tutorial: {
      text: "Tutorial",
      link: "https://youtu.be/iGaufrACVj4",
      icon: "fab.fa-youtube",
      colour: "#FF4444"
    }
  }
  const stopConfigs = [
    [0.5],
    [0.4, 0.8],
    [1/3, 2/3],
    [0.3, 0.6, 0.8],
    [0.2, 0.6],
    [0.2, 0.5, 0.8],
    [0.2, 0.4, 0.7],
    [0.2, 0.4, 0.6, 0.8]
  ]
  const stats = []
  Plugin.register(id, {
    title: name,
    icon: "icon.png",
    author: "Ewan Howell",
    description,
    tags: ["Minecraft", "Title", "Logo"],
    version: "1.4.1",
    min_version: "4.8.0",
    variant: "both",
    creation_date: "2023-06-10",
    await_loading: true,
    async onload() {
      styles = Blockbench.addCSS(`
        body:not(.is_mobile) #work_screen:has(#panel_minecraft_title_render_panel:not(.hidden)) {
          grid-template-columns: 0px auto 0 !important;
        }
        #panel_minecraft_title_render_panel > .panel_handle, #work_screen:has(#panel_minecraft_title_render_panel:not(.hidden)) > .resizer.vertical {
          display: none !important;
        }
        #work_screen:has(#panel_minecraft_title_render_panel:not(.hidden)) > #center {
          margin-bottom: calc(4px - var(--toolbar-height));
        }
        #panel_minecraft_title_render_panel {
          width: 0px !important; 
          height: 0px !important;
        }
        #minecraft-title-render-controls-container {
          position: absolute;
          left: 0;
          right: 0;
          bottom: 50px;
          display: flex;
          justify-content: center;
        }
        #minecraft-title-render-controls {
          background-color: var(--color-ui);
          z-index: 2;
          padding: 10px;
          box-shadow: 0 5px 10px #0006;
          display: flex;
          gap: 10px;
          align-items: center;
          flex-direction: column;
        }
        .minecraft-title-render-controls-row {
          display: flex;
          gap: 20px;
          align-items: center;
        }
        #minecraft-title-render-button {
          background-color: var(--color-close);
          color: var(--color-light);
          padding: 10px 30px 1px;
          border-radius: 8px;
          cursor: pointer;
          transition: filter .15s;
        }
        #minecraft-title-render-button:hover {
          filter: brightness(1.25) hue-rotate(5deg);
        }
        #minecraft-title-render-button.disabled {
          background-color: var(--color-button);
          cursor: not-allowed;
        }
        minecraft-title-render-button.disabled:hover {
          filter: initial;
        }
        .minecraft-title-button {
          cursor: pointer;
          border-radius: 4px;
        }
        .minecraft-title-button.selected {
          background-color: var(--color-accent);
          color: var(--color-accent_text);
        }
        .minecraft-title-button.selected > svg {
          fill: var(--color-accent_text);
        }
        #resolutions {
          display: flex;
          background-color: var(--color-button);
          padding: 4px;
        }
        .resolution {
          width: 32px;
          height: 32px;
        }
        .resolution > i {
          font-size: 32px;
        }
        .resolution > svg {
          fill: var(--color-text);
        }
        .minecraft-title-list {
          display: flex;
          max-height: 384px;
          flex-wrap: wrap;
          gap: 10px;
          overflow-x: hidden;
        }
        .minecraft-title-list.small {
          max-height: 256px;
        }
        .minecraft-title-item {
          display: flex;
          flex-direction: column;
          gap: 5px;
          padding: 10px 10px 5px;
          background-color: var(--color-back);
          align-items: center;
          cursor: pointer;
          flex: 1;
          position: relative;
          min-width: 150px;
        }
        .minecraft-title-item:hover {
          background-color: var(--color-button);
        }
        .minecraft-title-item > img {
          max-width: 100px;
          height: 50px;
          display: flex;
          object-fit: contain;
        }
        .minecraft-title-item > div:first-child {
          flex: 1;
          display: flex;
          align-items: center;
          margin-bottom: 5px;
        }
        .minecraft-title-item > div:nth-child(2) {
          text-align: center;
          flex: 1;
          display: flex;
          align-items: center;
          max-height: 24px;
          min-height: 24px;
          line-height: 16px;
          margin: -2px 0 2px;
        }
        .minecraft-title-item.selected {
          outline: 2px solid var(--color-accent);
          background-color: var(--color-button);
          outline-offset: -2px;
        }
        .minecraft-title-item-has-variants {
          display: flex;
          position: absolute;
          bottom: 4px;
          right: 4px;
          z-index: 1;
        }
        .minecraft-title-links {
          display: flex;
          justify-content: space-around;
          margin: 20px 40px 0;
        }
        .minecraft-title-links > a {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 5px;
          padding: 5px;
          text-decoration: none;
          flex-grow: 1;
          flex-basis: 0;
          color: var(--color-subtle_text);
          text-align: center;
        }
        .minecraft-title-links > a:hover {
          background-color: var(--color-accent);
          color: var(--color-light);
        }
        .minecraft-title-links > a > i {
          font-size: 32px;
          width: 100%;
          max-width: initial;
          height: 32px;
          text-align: center;
        }
        .minecraft-title-links > a:hover > i {
          color: var(--color-light) !important;
        }
        .minecraft-title-links > a > p {
          flex: 1;
          display: flex;
          align-items: center;
        }
        .spacer, #minecraft_title_generator .sp-preview, #minecraft_title_generator .form_inline_select > li {
          flex: 1;
        }
        #minecraft_title_generator .form_inline_select > .disabled {
          cursor: not-allowed;
          color: inherit !important;
          text-decoration: line-through;
          opacity: 0.5;
        }
        .minecraft-title-item-buttons > i:hover, #minecraft-title-preview-container > i:hover, .minecraft-title-button:hover, #minecraft-title-custom-texture > i:hover, .text-input-row > i:hover, .minecraft-title-button:hover > svg {
          color: var(--color-light);
        }
        .minecraft-title-preset > *, .minecraft-title-item *, .text-input-row > i:hover, #minecraft-title-render-button-row *, .minecraft-title-links * {
          cursor: pointer;
        }
        #format_page_minecraft_title {
          padding-bottom: 0;
        }
        #format_page_minecraft_title .format_target {
          margin-bottom: 6px;
        }
        #format_page_minecraft_title div:nth-child(3), #format_page_minecraft_title content {
          overflow-y: auto;
        }
      `)
      let shadeState
      BarItems.toggle_shading.condition = () => Project.format?.id !== format.id
      format = new ModelFormat({
        id: "minecraft_title",
        name: "Minecraft Title",
        icon,
        category: "minecraft",
        target: ["Minecraft"],
        render_sides: "front",
        model_identifier: false,
        rotate_cubes: true,
        uv_rotation: true,
        bone_rig: true,
        centered_grid: true,
        onSetup: loadRenderAngle,
        new() {
          newProject(this)
          Project.texture_width = 1000
          Project.texture_height = 320
          dialog.show()
        },
        onActivation() {
          shadeState = BarItems.toggle_shading.value
          if (shadeState) BarItems.toggle_shading.click()
        },
        onDeactivation() {
          if (shadeState) BarItems.toggle_shading.click()
          dialog.close()
        },
        format_page: {
          component: {
            methods: {
              create: () => format.new()
            },
            template: `
              <div style="display:flex;flex-direction:column;height:100%">
                <p class="format_description">${description}</p>
                <p class="format_target"><b>Target</b> : <span>Logos</span> <span>Renders</span> <span>Thumbnails</span></p>
                <content>
                  <h3 class="markdown">Good to know:</h3>
                  <p class="markdown">
                    <ul>
                      <li>This format is designed to create Minecraft-styled title models.</li>
                      <li>New text can be added with the <strong>Add Minecraft Title Text</strong> button <i class="icon material-icons" style="font-size:20px">text_fields</i>.</li>
                      <li>There are automatic presets for text positions and text angles, so make sure to check out all of the text options!</li>
                      <li>To render your title, you can use the <strong>Render</strong> mode found at the top right.</li>
                      <li>The camera can be automatically positioned in the render mode using the <strong>Position camera</strong> button <i class="icon material-icons" style="font-size:20px">auto_mode</i>.</li>
                    </ul>
                  </p>
                </content>
                <div class="spacer"></div>
                <div class="minecraft-title-links">${Object.values(links).map(e => `
                  <a href="${e.link}">
                    ${Blockbench.getIconNode(e.icon, e.colour).outerHTML}
                    <p>${e.text}</p>
                  </a>
                `).join("")}</div>
                <div class="button_bar">
                  <button id="create_new_model_button" style="margin-top:20px;margin-bottom:24px;" @click="create">
                    <i class="material-icons">${icon}</i>
                    Create New Minecraft Title
                  </button>
                </div>
              </div>
            `
          }
        }
      })
      mode = new Mode("minecraft_title_render", {
        name: "Render",
        category: "navigate",
        condition: {
          formats: [format.id]
        },
        hide_toolbars: true,
        hide_status_bar: true,
        onSelect() {
          three_grid.visible = false
          const pivot = Canvas.scene.getObjectByName("pivot_marker")
          if (pivot) pivot.visible = false
          setTimeout(selectHandler, 0)
        },
        onUnselect() {
          three_grid.visible = true
          const pivot = Canvas.scene.getObjectByName("pivot_marker")
          if (pivot) pivot.visible = true
          Canvas.scene.traverse(e => {
            if (e.type === "Line") e.visible = true
          })
        }
      })
      action = new Action("minecraft_title_add_text", {
        name: "Add Minecraft Title Text",
        icon,
        condition: () => Project.format === format,
        click: () => dialog.show()
      })
      Toolbars.outliner.add(action, 0)
      MenuBar.menus.edit.addAction(action, 4)
      Interface.Panels.outliner.menu.addAction(action, 0)
      panel = new Panel("minecraft_title_render_panel", {
        name: "Render Controls",
        icon: "photo_camera",
        condition: {
          modes: ["minecraft_title_render"]
        },
        component: {
          methods: {
            render() {
              if (Preview.selected.camera instanceof THREE.OrthographicCamera) return Blockbench.showMessageBox({
                title: "Orthographic not supported",
                message: "Orthographic perspectives are not supported for render mode.\n\nIf you wish to render with an orthographic perspective, use the built-in Blockbench screenshot options.",
                buttons: ["Disable orthographic perspective", "dialog.close"],
                width: 500
              }, async button => {
                if (button === 0) Preview.selected.setProjectionMode(false)
              })
              if (this.rendering) return
              this.rendering = true
              const args = this
              const dialog = new Dialog({
                id: "minecraft_title_render_result",
                title: "Renderingâ€¦",
                buttons: [],
                lines: [`<style>
                  #minecraft_title_render_result .hidden {
                    display: none;
                  }
                  #minecraft_title_render_result .dialog_content {
                    margin: 0;
                  }
                  #minecraft-title-output {
                    max-width: 100%;
                    min-height: 32px;
                    border: 1px solid var(--color-accent);
                    object-fit: contain;
                  }
                  #minecraft-title-render-content {
                    margin: 20px;
                  }
                  #minecraft-title-render-content, #minecraft-title-render-output {
                    display: flex;
                    align-items: center;
                    flex-direction: column;
                  }
                  #minecraft-title-render-button-row {
                    width: 100%;
                    display: flex;
                    gap: 10px;
                    flex-wrap: wrap;
                  }
                  #minecraft-title-render-button-row > button {
                    flex: 1;
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                    align-items: center;
                    text-decoration: none;
                    height: 40px;
                    min-width: 200px;
                  }
                  #minecraft-title-render-button-row > button:focus > div {
                    text-decoration: underline;
                  }
                  #render-detail-row {
                    display: flex;
                    justify-content: space-between;
                    width: 100%;
                    gap: 10px;
                  }
                  #minecraft-title-render-output {
                    gap: 10px;
                    width: 100%;
                    height: calc(100vh - 180px - 40px);
                  }
                  #minecraft-title-render-output > .form_inline_select {
                    width: 100%;
                    flex-grow: initial;
                  }
                  .minecraft-output-options {
                    display: flex;
                    gap: 10px;
                    width: 100%;
                    align-items: center;
                    flex-wrap: wrap;
                    justify-content: space-between;
                  }
                  .minecraft-output-options.disabled {
                    pointer-events: none;
                    opacity: 0.5;
                  }
                  .minecraft-output-options.disabled .sp-preview-inner {
                    filter: grayscale();
                  }
                  .minecraft-output-options.disabled .sp-preview::after {
                    content: "";
                    position: absolute;
                    inset: 0;
                    background: linear-gradient(to top right, transparent calc(50% - 2px), var(--color-close) calc(50% - 1px) calc(50% + 1px), transparent calc(50% + 2px)), linear-gradient(to top left, transparent calc(50% - 2px), var(--color-close) calc(50% - 1px) calc(50% + 1px), transparent calc(50% + 2px));
                  }
                  .minecraft-output-label {
                    font-size: 1.25em;
                  }
                  .minecraft-output-options bb-select {
                    flex: 1;
                    cursor: pointer;
                  }
                  .minecraft-output-options > div {
                    display: flex;
                    gap: 10px;
                    align-items: center;
                  }
                  .minecraft-output-options input:not([type='checkbox']) {
                    width: 60px;
                  }
                  .minecraft-output-options input[type='checkbox'] {
                    cursor: pointer;
                  }
                </style>`],
                component: {
                  data: {
                    rendering: true,
                    image: null,
                    dimensions: null,
                    size: null,
                    canvas: null,
                    tab: "normal",
                    resolutionWidth: 1920,
                    resolutionHeight: 1080,
                    aspectWidth: 16,
                    aspectHeight: 9,
                    lastChanged: "width",
                    linked: true,
                    minecraftMode: "1.20",
                    minecraftModes: {
                      "1.20": "1.20+ Title Texture",
                      "1.19": "1.19- Title Texture",
                      mojang: "Mojang Studios Texture"
                    },
                    backgroundColour: "#78b8ff",
                    backgroundColour2: "#c7ecff",
                    backgroundColourEnabled: false,
                    backgroundColour2Enabled: false,
                    updating: false,
                    tabToUpdate: false,
                    padding: 0
                  },
                  mounted() {
                    $(this.$refs.backgroundColour).spectrum(this.colourInput("backgroundColour")),
                    $(this.$refs.backgroundColour2).spectrum(this.colourInput("backgroundColour2"))
                  },
                  methods: {
                    async copy() {
                      const r = await fetch(this.canvas.toDataURL())
                      navigator.clipboard.write([new ClipboardItem({ "image/png": await r.blob() })])
                      Blockbench.showQuickMessage("Copied to clipboard")
                    },
                    save() {
                      Blockbench.export({
                        extensions: ["png"],
                        type: tl("data.image"),
                        savetype: "image",
                        name: Project.name || "minecraft_title",
                        content: this.canvas.toDataURL()
                      }, () => Blockbench.showQuickMessage("Saved title"))
                    },
                    async tabChange(tab) {
                      this.tab = tab
                      let canvas, ctx
                      if (tab === "normal") {
                        ({ canvas, ctx } = new CanvasFrame(this.image.width, this.image.height))
                        ctx.drawImage(this.image, 0, 0)
                      } else if (tab === "square") {
                        const max = Math.max(this.image.width, this.image.height);
                        ({ canvas, ctx } = new CanvasFrame(max, max))
                        ctx.drawImage(this.image, Math.floor(max / 2 - this.image.width / 2), Math.floor(max / 2 - this.image.height / 2))
                      } else if (tab === "custom") {
                        ({ canvas, ctx } = new CanvasFrame(this.resolutionWidth, this.resolutionHeight))
                        const aspect = this.image.width / this.image.height
                        const ratio = Math.min(canvas.width / this.image.width, canvas.height / this.image.height)
                        const w = Math.floor(this.image.width * ratio)
                        const h = Math.floor(this.image.height * ratio)
                        ctx.drawImage(this.image, Math.floor(canvas.width / 2 - w / 2), Math.floor(canvas.height / 2 - h / 2), w, h)
                      } else if (tab === "minecraft") {
                        const aspect = this.image.width / this.image.height
                        let w, h
                        if (this.image.width > 1024 || this.image.height > 1024) {
                          if (aspect > 1) {
                            w = 1024
                            h = Math.floor(1024 / aspect)
                          } else {
                            h = 1024
                            w = Math.floor(1024 * aspect)
                          }
                        } else {
                          w = this.image.width
                          h = this.image.height
                        }
                        const capped = new CanvasFrame(w, h)
                        if (this.image.width < 64 || this.image.height < 64) capped.ctx.imageSmoothingEnabled = false
                        capped.ctx.drawImage(this.image, 0, 0, w, h)
                        capped.autoCrop()
                        if (this.minecraftMode === "1.20") {
                          ({ canvas, ctx } = new CanvasFrame(1024, 256))
                          const scaleFactor = Math.min(1024 / capped.width, 176 / capped.height)
                          const newWidth = capped.width * scaleFactor
                          const newHeight = capped.height * scaleFactor
                          const x = (1024 - newWidth) / 2
                          const y = (176 - newHeight) / 2
                          if (newWidth > capped.width) ctx.imageSmoothingEnabled = false
                          ctx.drawImage(capped.canvas, x, y, newWidth, newHeight)
                        } else if (this.minecraftMode === "1.19") {
                          const base = await loadImage("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAJ1BMVEUAAAD///8AAAACAQEeHB8jHh5FQkNTUFODfHylnJmon5yvpKDIw79IVPQIAAAAAnRSTlMAAHaTzTgAAAgfSURBVHhe7M6xAAAAAAKwFPKXDaNnI1h6dg8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjBUzaG7buOK4Kn6RDNC0VOQDiweQmolOBWl3JjqVppSZ6iRGtGeiU2ibqq0T2ZhwyZOmaYiKJ1/SSjqpjS1pcZJkiTT3Q/X/3i5BR5kRZjT8H4CHh8Xub997Cyy5AOUIKqQGpSrkaA4q/CYLYLHRaGwTA6zDcos4hEGr1WoWco9wCostq+e0MTW3/NYTa9Lvp85nHnxG9cAYL1qtzzIBAqXUO2KSnlJn7l9w2VxR6vC/hdy354dH1fz54aE6PFJH7+mlOleidqDeiHGkaPlIGfc7r8ennrkvOj1QYSZACQAnnAPiJ9xvcazmYb6l3CvY4ZKyek+4NtoPVGysX98fgODEg2FompkAS0pP2kQLVExnQcs8C1q0ttU76qUAvhpYs55XiZ6gD8AjehBi8zO6OWP7lWpnAeT+FEXR8yqR/3C3p/7nHXEevlLn7HsUDSfulzyrCPpe4CLWd746VaetngE4dfLK+1wpafpj9Bz90dfRa1ycP4o6f8gCkLjtE+HcQy4wWpc4D+rSA8tAptUmlgBUSQQAk65mCcB5uJWiLySbVjwVBSMrAosHCmqSd8AA7WKaTMBMpCjOj3D7NkAysgXbwRNuMa56EgylrlIAiU82gI9RVBISj9bj+UgGbaUBgJ5GBynAUCcW4GkXAGtKCbK+dlY1B0MqxUrC2Ml+D5QUy3E+j/71791uuGRjD7V/l0Zjy4Fc7+AsigyANzmLDpxVqccJUHg4Gz6HBQetShQXsgAwopSWWdfuA16A6BM6+zvsa4nGf+J/xvE/kKXkI4mAmExiXP/RRegSAGwaFtbpRIqGe74qZAHk1lSikySZaI2Oxu4mLtpFbYQ7H7z+ROPuSOsr7xi+0ADABU0QEA8GOe6qnlx4OmHnONEXACjpib7JBtjTn+iG+LJZYrPWZ8+llwjLyJopgGXsdhjrz8dXy0w41II11B8AEMAcf5YFsIhnZsJ8YVTzqakxK9GYAd7cBpB2Q2Acj15pfU1gZvX1DUOymVkDPhMfYBI9Jrk0Dy3Ppn5CfHwTD97E++amSOYa93C4NqCz+J2pH1+qn1wiuVHPApBoO309djZhvRUe5DOd+r54TGXbKbEEYCtvR7UauZuM7PzWk1UgOO0sgPzgGLlLLH2naPuRkVlSkB9dYt0GqK9wa9oRgJT8knwyknlkvAdyqyjZEx+pTLsEy1O8+5vkbhwMDNLYANAnAP1BHNdLgrsj005zd01TBU/j+IcsgL2RnnDVX5DpIS2/Jud5ZFbE6FMAkddHm2YxHmDlrknCetPqvUk3VhsJ+DIAFoc3cUTFKNoqmhim5VcnnEa6XopRIA1WXQDE/MbrDyVhs2eOzwfdsDQN1wIAfL6t3bsBSKMjlyq1xysmnGn5heTBocMltBD1uSqsrokB2maEBzZqlkinANJP9W6Aku7hg0dBrfalqegJ+g1MNxhvjKQYgNNDnQKMDYB1uMvpWtgnQec9bm66Vjt3AyzpifoZtOXampZX2VhehBNEljAdhfkZgETAjEYA2MOM35rxlthFs9jVEQABEKiTuwFkpRAhBHumgxtZCgnXHRLaBwAO0DHmAoCIx7kBwCs7nq08lKKpBJ4zFSyATOruHdFKFEV1gmpfw9qi6Nku1+RG9D2gomjjNZWiRgQ94Q9x1N0OdiO0+Rs9xLnu7T6Pumj3epfb8dLlXqr210ZofHcDUA0iKHgM4zFVcKxapzkFtW9qRiEc2xVuhiYV41jnFnCnDogWWES+ubobIBfwiCGBV1D89SkGfHLyLYAFs6a9J9BBCu2LWbAAgVxlbckIXYQMMO1nGxhiph6rcjg118Vr24XCQsLi+2U4UgAflJlbMoSgsQ0AoNg+QWFU8MUycI/ZKJcrtTJUEYAy+WXQYwU1qjDLTNiQDNgUMH/2lowkjCQo6NQHgDfd1oWwRGSdblAjPgKgIUhSPxWYIt9kQJQzkSlkAuRMHAUF4+Ox6qrZaQDgK6Xwy/DwJyqH+Rhq+xXvr3Ez4GzU/SgCYnc3rIS++SlKMqQFsAHIAIA4egKQE4PKtCkAFw6JZb4vzhdstF3eZnR8wkNE8r5OdB1Xdj8gPVkAk8ZsAGlpsMlqLx12Zr08ZmP8AwO0yUhr/Azj72axq0Wu7WkGsJANcFuy2Xjfau3xhx2bO/lVyNYoivr6gwAUhNsD0RWHRV7aiewVbut+ABpS2gz28fzIJfolwD4DkACMZNsYaP3kRaPhUGEuAKRFgw4SbAPLKKJPAeSu+ZbYDMwHIFfUorM25pgCHBvnNQOcWIChRu439SWRI/vCF/X5AKwgAUpxaEkKTwD0FIAAQCKgvNd6ldcrrZlYzAdgWWvHcbTucG67Leg7Bmg7zpoBuJZdGVsXjvOAfZUatKOv5gPwQI9kjTWppKdZ9piHNnm2/dki5fRL69Q3F4A17hyFUKeVOwBGKQBytGPysz0XANrDMDw20dItgB0GGKYAiDkREuaaEsDVfABm8isVuxXxGo2Q6GGjTrTeEG0jSnwZNBqu/bPy2XxeRDm6t+4BMF+ChbkAQHQvFRbmBADdb/w5AkgaCnRLv3LkssIvAP9vz44FAAAAAIT5W2cQwSLYn2NyAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEmBOKRi4Y7csAAAAASUVORK5CYII=")
                          let preCanvas
                          if (capped.width / capped.height < 137 / 22) {
                            preCanvas = new CanvasFrame(Math.floor((capped.height / 22) * 137), capped.height)
                            preCanvas.ctx.drawImage(capped.canvas, Math.floor((preCanvas.width - capped.width) / 2), 0)
                          } else if (capped.width / capped.height > 137 / 22) {
                            preCanvas = new CanvasFrame(capped.width, Math.floor((capped.width / 137) * 22))
                            preCanvas.ctx.drawImage(capped.canvas, 0, Math.floor((preCanvas.height - capped.height) / 2))
                          } else preCanvas = capped;
                          ({ canvas, ctx } = new CanvasFrame(Math.floor((preCanvas.width / 137) * 128), Math.floor((preCanvas.width / 137) * 128), true, 1024))
                          ctx.imageSmoothingEnabled = false
                          ctx.drawImage(base, 0, 0, canvas.width, canvas.height)
                          const width = Math.floor((preCanvas.width / 274) * 155)
                          ctx.drawImage(preCanvas.canvas, 0, 0, width, preCanvas.height, 0, 0, width, preCanvas.height)
                          ctx.drawImage(preCanvas.canvas, width, 0, preCanvas.width - width, preCanvas.height, 0, Math.floor(preCanvas.height / 44 * 45), preCanvas.width - width, preCanvas.height)
                        } else if (this.minecraftMode === "mojang") {
                          let preCanvas
                          if (capped.width < capped.height * 4) {
                            preCanvas = new CanvasFrame(capped.height * 4 + 8, capped.height + 2)
                            preCanvas.ctx.drawImage(capped.canvas, Math.floor((capped.height * 4 - capped.width) / 2) + 4, 1)
                          } else if (capped.width > capped.height * 4) {
                            preCanvas = new CanvasFrame(capped.width + 8, Math.floor(capped.width / 4) + 2)
                            preCanvas.ctx.drawImage(capped.canvas, 4, Math.floor((preCanvas.height - capped.height) / 2))
                          } else {
                            preCanvas = new CanvasFrame(capped.width + 8, capped.height + 4)
                            preCanvas.ctx.drawImage(capped.canvas, 4, 1)
                          }
                          ({ canvas, ctx } = new CanvasFrame(Math.floor(preCanvas.width / 2), Math.floor(preCanvas.width / 2)))
                          ctx.drawImage(preCanvas.canvas, 0, 0)
                          ctx.drawImage(preCanvas.canvas, Math.floor(-preCanvas.width / 2), Math.floor(preCanvas.width / 4))
                        }
                      }
                      const padding = tab === "minecraft" ? 0 : this.padding
                      this.canvas.width = canvas.width + padding * 2
                      this.canvas.height = canvas.height + padding * 2
                      if (this.tab !== "minecraft" && this.backgroundColourEnabled) {
                        if (this.backgroundColour2Enabled) {
                          const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height)
                          gradient.addColorStop(0, this.backgroundColour)
                          gradient.addColorStop(1, this.backgroundColour2)
                          this.ctx.fillStyle = gradient
                        } else {
                          this.ctx.fillStyle = this.backgroundColour
                        }
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)
                      }
                      this.ctx.drawImage(canvas, padding, padding)
                      const size = this.canvas.toDataURL().slice(22).length * 0.75
                      this.dimensions = `${this.canvas.width} x ${this.canvas.height}`
                      this.size = `${size > 1048576 ? `${Math.roundTo(size / 1048576, 2)} MB` : `${Math.round(size / 1024)} KB`}`
                    },
                    changeResolution(changed) {
                      this.lastChanged = changed
                      if (this.linked) {
                        if (changed === "width") {
                          this.resolutionHeight = Math.max(1, Math.floor((this.resolutionWidth * this.aspectHeight) / this.aspectWidth))
                        } else {
                          this.resolutionWidth = Math.max(1, Math.floor((this.resolutionHeight * this.aspectWidth) / this.aspectHeight))
                        }
                        if (this.resolutionWidth > 4096 || this.resolutionHeight > 4096) {
                          const aspect = this.resolutionWidth / this.resolutionHeight
                          if (aspect > 1) {
                            this.resolutionWidth = 4096
                            this.resolutionHeight = Math.floor(4096 / aspect)
                          } else {
                            this.resolutionHeight = 4096
                            this.resolutionWidth = Math.floor(4096 * aspect)
                          }
                        }
                      } else {
                        this.resolutionWidth = Math.max(1, parseInt(this.resolutionWidth))
                        this.resolutionHeight = Math.max(1, parseInt(this.resolutionHeight))
                        const [aW, aH] = getAspectRatio(this.resolutionWidth, this.resolutionHeight)
                        this.aspectWidth = aW
                        this.aspectHeight = aH
                      }
                      this.update("custom")
                    },
                    changeAspect() {
                      this.aspectWidth = Math.max(1, parseInt(this.aspectWidth))
                      this.aspectHeight = Math.max(1, parseInt(this.aspectHeight))
                      const [w, h] = getFromAspect(this.aspectWidth, this.aspectHeight, this.resolutionWidth, this.resolutionHeight, this.lastChanged === "width")
                      this.resolutionWidth = w
                      this.resolutionHeight = h
                      this.update("custom")
                    },
                    colourInput: v => ({
                      preferredFormat: "hex",
                      color: dialog.component.data[v],
                      showAlpha: false,
                      showInput: true,
                      move: c => dialog.content_vue.updateColour(v, c),
                      change: c => dialog.content_vue.updateColour(v, c),
                      hide: c => dialog.content_vue.updateColour(v, c)
                    }),
                    updateColour(v, c) {
                      this[v] = c.toHexString()
                      this.update(this.tab)
                    },
                    async update(tab) {
                      if (this.updating) {
                        this.tabToUpdate = tab
                        return
                      }
                      this.updating = true
                      await this.tabChange(tab)
                      this.updating = false
                      if (this.tabToUpdate) {
                        this.update(this.tabToUpdate)
                        this.tabToUpdate = false
                      }
                    }
                  },
                  template: `
                    <div id="minecraft-title-render-content">
                      <h1 v-if="rendering" style="text-align:center">Renderingâ€¦</h1>
                      <div id="minecraft-title-render-output" :style="{ display: rendering ? 'none' : 'flex' }">
                        <ul class="form_inline_select">
                          <li @click="update('normal')" :class="{ selected: tab === 'normal' }">Normal</li>
                          <li @click="update('square')" :class="{ selected: tab === 'square' }">Square</li>
                          <li @click="update('custom')" :class="{ selected: tab === 'custom' }">Custom</li>
                          <li @click="update('minecraft')" :class="{ selected: tab === 'minecraft' }">Minecraft</li>
                        </ul>
                        <div class="minecraft-output-options" :style="{ display: tab === 'custom' ? 'flex' : 'none' }">
                          <div>
                            <div class="minecraft-output-label">Resolution:</div>
                            <numeric-input v-model="resolutionWidth" step="1" :min="1" :max="4096" @input="changeResolution('width')" />
                            <div class="minecraft-output-label" style="margin: 0 -5px">â¨‰</div>
                            <numeric-input v-model="resolutionHeight" step="1" :min="1" :max="4096" @input="changeResolution('height')" />
                            <div class="tool" :class="{ enabled: linked }" @click="linked = !linked">
                              <div class="tooltip" style="margin-left: 0px;">Link width and height</div>
                              <i class="fa_big icon fas fa-link"></i>
                            </div>
                          </div>
                          <div>
                            <div class="minecraft-output-label">Aspect Ratio:</div>
                            <numeric-input v-model="aspectWidth" step="1" :min="1" :max="4096" @input="changeAspect" />
                            <div class="minecraft-output-label" style="margin: 0 -5px">:</div>
                            <numeric-input v-model="aspectHeight" step="1" :min="1" :max="4096" @input="changeAspect" />
                          </div>
                        </div>
                        <div class="minecraft-output-options" :style="{ display: tab === 'minecraft' ? 'none' : 'flex' }">
                          <div>
                            <div class="minecraft-output-label">Background Colour:</div>
                            <input type="checkbox" :checked="backgroundColourEnabled" v-model="backgroundColourEnabled" @input="backgroundColourEnabled = !backgroundColourEnabled; update(tab)" />
                            <div :class="{ hidden: !backgroundColourEnabled }">
                              <input ref="backgroundColour" />
                            </div>
                          </div>
                        </div>
                        <div class="minecraft-output-options" :class="{ hidden: tab === 'minecraft', disabled: !backgroundColourEnabled }">
                          <div>
                            <div class="minecraft-output-label">Second Background Colour:</div>
                            <input type="checkbox" :checked="backgroundColour2Enabled" v-model="backgroundColour2Enabled" @input="backgroundColour2Enabled = !backgroundColour2Enabled; update(tab)" />
                            <div :class="{ hidden: !backgroundColour2Enabled }">
                              <input ref="backgroundColour2" />
                            </div>
                          </div>
                        </div>
                        <div class="minecraft-output-options" :style="{ display: tab === 'minecraft' ? 'none' : 'flex' }">
                          <div>
                            <div class="minecraft-output-label">Padding:</div>
                            <numeric-input v-model="padding" step="1" :min="0" :max="1024" @input="update(tab)" />
                          </div>
                        </div>
                        <div class="minecraft-output-options" :style="{ display: tab === 'minecraft' ? 'flex' : 'none' }">
                          <div class="minecraft-output-label">Texture mode:</div>
                          <select-input v-model="minecraftMode" :options="minecraftModes" @input="update('minecraft')" />
                        </div>
                        <div class="spacer"></div>
                        <canvas id="minecraft-title-output" class="checkerboard" />
                        <div class="spacer"></div>
                        <div id="render-detail-row">
                          <div>{{ dimensions }}</div>
                          <div>{{ size }}</div>
                        </div>
                        <div id="minecraft-title-render-button-row">
                          <button @click="copy">
                            <i class="material-icons icon">file_copy</i>
                            <div>Copy render</div>
                          </button>
                          <button @click="save">
                            <i class="material-icons icon">save</i>
                            <div>Save render</div>
                          </button>
                        </div>
                      </div>
                    </div>
                  `
                },
                onOpen() {
                  setTimeout(() => Canvas.withoutGizmos(() => {
                    let minX = Infinity
                    let maxX = -Infinity
                    let minY = Infinity
                    let maxY = -Infinity
                    const direction = Preview.selected.controls.target.clone().sub(Preview.selected.camera.position).normalize()
                    Canvas.scene.traverseVisible(cube => {
                      if (cube.type === "cube") {
                        for (let i = 0; i < 72; i += 3) {
                          const vertex = new THREE.Vector3(...cube.geometry.attributes.position.array.slice(i, i + 3))
                          if (direction.dot(vertex.clone().sub(Preview.selected.camera.position).normalize()) <= 0) continue
                          const vec = vertex.applyMatrix4(cube.matrixWorld).project(Preview.selected.camera)
                          const x = (vec.x + 1) / 2
                          const y = (-vec.y + 1) / 2
                          minX = Math.min(minX, x)
                          maxX = Math.max(maxX, x)
                          minY = Math.min(minY, y)
                          maxY = Math.max(maxY, y)
                        }
                      }
                    })
                    if (minX === Infinity) {
                      dialog.close()
                      Blockbench.showQuickMessage("Nothing in frame")
                      args.rendering = false
                      return
                    }
                    minX = Math.max(minX, 0)
                    maxX = Math.min(maxX, 1)
                    minY = Math.max(minY, 0)
                    maxY = Math.min(maxY, 1)
                    if (minX === maxX || minY === maxY) {
                      dialog.close()
                      Blockbench.showQuickMessage("Nothing in frame")
                      args.rendering = false
                      return
                    }
                    const aspect = (maxX - minX) / ((maxY - minY) * Preview.selected.height / Preview.selected.width)
                    let outWidth, outHeight
                    const resolution = args.antialias ? Math.min(args.resolution * 2, 4096) : args.resolution
                    if (aspect > 1) {
                      outWidth = resolution
                      outHeight = resolution / aspect
                    } else {
                      outWidth = resolution * aspect
                      outHeight = resolution
                    }
                    preview.resize(outWidth, outHeight)
                    preview.controls.target.copy(Preview.selected.controls.target)
                    preview.camera.position.copy(Preview.selected.camera.position)
                    const fullWidth = outWidth / (maxX - minX)
                    const fullHeight = outHeight / (maxY - minY)
                    preview.camera.setViewOffset(fullWidth, fullHeight, minX * fullWidth, minY * fullHeight, outWidth, outHeight)
                    preview.render()
                    const img = new CanvasFrame(preview.canvas)
                    img.autoCrop()
                    const imageData = img.ctx.getImageData(0, 0, img.width, img.height)
                    const data = imageData.data
                    const length = data.length
                    const width = img.width
                    const height = img.height
                    const width1 = width - 1
                    const height1 = height - 1
                    for (let i = length - 4; i >= 0; i -= 4) {
                      const x = i / 4 % img.width
                      const y = Math.floor(i / (4 * height))
                      if (data[i + 3] === 0) {
                        if (
                          (x === 0 || data[i - 1] !== 0) &&
                          (x === width1 || data[i + 7] !== 0) &&
                          (y === 0 || data[i - width * 4 + 3] !== 0) &&
                          (y === height1 || data[i + width * 4 + 3] !== 0)
                        ) {
                          let count = 0
                          let sr, sg, sb, sa
                          sr = sg = sb = sa = 0
                          if (x !== 0) {
                            count++
                            sr += data[i - 4]
                            sg += data[i - 3]
                            sb += data[i - 2]
                            sa += data[i - 1]
                          }
                          if (x !== width1) {
                            count++
                            sr += data[i + 4]
                            sg += data[i + 5]
                            sb += data[i + 6]
                            sa += data[i + 7]
                          }
                          if (y !== 0) {
                            count++
                            sr += data[i - width * 4]
                            sg += data[i - width * 4 + 1]
                            sb += data[i - width * 4 + 2]
                            sa += data[i - width * 4 + 3]
                          }
                          if (y !== height1) {
                            count++
                            sr += data[i + width * 4]
                            sg += data[i + width * 4 + 1]
                            sb += data[i + width * 4 + 2]
                            sa += data[i + width * 4 + 3]
                          }
                          data[i] = sr / count
                          data[i + 1] = sg / count
                          data[i + 2] = sb / count
                          data[i + 3] = sa / count
                        } else {
                          const store = []
                          const queue = [i]
                          while (store.length < 6 && queue.length !== 0) {
                            const j = queue.shift()
                            store.push(j)
                            const x = j / 4 % img.width
                            if (x !== 0 && data[j - 1] === 0 && !store.includes(j - 4)) queue.push(j - 4)
                            if (x !== width1 && data[j + 7] === 0 && !store.includes(j + 4)) queue.push(j + 4)
                            if (Math.floor(j / (4 * height)) !== 0 && data[j - width * 4 + 3] === 0 && !store.includes(j - width * 4)) queue.push(j - width * 4)
                          }
                          if (store.length >= 6) continue
                          for (const j of store) {
                            const x = j / 4 % img.width
                            const y = Math.floor(j / (4 * height))
                            let count = 0
                            let sr, sg, sb, sa
                            sr = sg = sb = sa = 0
                            if (x !== 0 && data[j - 1] !== 0) {
                              count++
                              sr += data[j - 4]
                              sg += data[j - 3]
                              sb += data[j - 2]
                              sa += data[j - 1]
                            }
                            if (x !== width1 && data[j + 7] !== 0) {
                              count++
                              sr += data[j + 4]
                              sg += data[j + 5]
                              sb += data[j + 6]
                              sa += data[j + 7]
                            }
                            if (y !== 0 && data[j - width * 4 + 3] !== 0) {
                              count++
                              sr += data[j - width * 4]
                              sg += data[j - width * 4 + 1]
                              sb += data[j - width * 4 + 2]
                              sa += data[j - width * 4 + 3]
                            }
                            if (y !== height1 && data[j + width * 4 + 3] !== 0) {
                              count++
                              sr += data[j + width * 4]
                              sg += data[j + width * 4 + 1]
                              sb += data[j + width * 4 + 2]
                              sa += data[j + width * 4 + 3]
                            }
                            data[j] = sr / count
                            data[j + 1] = sg / count
                            data[j + 2] = sb / count
                            data[j + 3] = sa / count
                          }
                        } 
                      } else if (
                        (x === 0 || data[i - 1] === 0) &&
                        (x === width1 || data[i + 7] === 0) &&
                        (y === 0 || data[i - width * 4 + 3] === 0) &&
                        (y === height1 || data[i + width * 4 + 3] === 0)
                      ) {
                        data[i + 3] = 0
                      } else {
                        const store = []
                        const queue = [i]
                        while (store.length < 6 && queue.length !== 0) {
                          const j = queue.shift()
                          store.push(j)
                          const x = j / 4 % img.width
                          if (x !== 0 && data[j - 1] !== 0 && !store.includes(j - 4)) queue.push(j - 4)
                          if (x !== width1 && data[j + 7] !== 0 && !store.includes(j + 4)) queue.push(j + 4)
                          if (Math.floor(j / (4 * height)) !== 0 && data[j - width * 4 + 3] !== 0 && !store.includes(j - width * 4)) queue.push(j - width * 4)
                        }
                        if (store.length >= 6) continue
                        for (const j of store) {
                          data[j + 3] = 0
                        }
                      }
                    }
                    img.ctx.putImageData(imageData, 0, 0)
                    img.autoCrop()
                    let out
                    if (args.antialias) {
                      const canvas = new CanvasFrame(img.width, img.height)
                      canvas.ctx.filter = "blur(0.75px)"
                      canvas.ctx.drawImage(img.canvas, 0, 0)
                      out = new CanvasFrame(Math.floor(img.width / 2), Math.floor(img.height / 2))
                      out.ctx.drawImage(canvas.canvas, 0, 0, out.width, out.height)
                    } else {
                      out = img
                    }
                    args.rendering = false
                    this.content_vue.rendering = false
                    this.content_vue.image = out.canvas
                    const size = out.canvas.toDataURL().slice(22).length * 0.75
                    this.content_vue.dimensions = `${out.canvas.width} x ${out.canvas.height}`
                    this.content_vue.size = `${size > 1048576 ? `${Math.roundTo(size / 1048576, 2)} MB` : `${Math.round(size / 1024)} KB`}`
                    dialog.object.style.width = `${Math.max(450, out.canvas.width)}px`
                    dialog.object.querySelector(".dialog_title").textContent = "Minecraft Title Render"
                    dialog.object.style.left = `${Math.clamp((window.innerWidth - dialog.object.clientWidth) / 2, 0, 2000)}px`
                    dialog.object.addEventListener("keydown", e => {
                      if (e.key === "Enter") return e.stopPropagation()
                    })
                    setTimeout(() => {
                      this.content_vue.canvas = dialog.object.querySelector("#minecraft-title-output")
                      this.content_vue.canvas.width = this.content_vue.image.width
                      this.content_vue.canvas.height = this.content_vue.image.height
                      this.content_vue.ctx = this.content_vue.canvas.getContext("2d")
                      this.content_vue.ctx.drawImage(this.content_vue.image, 0, 0)
                    }, 0)
                  }), 10)
                }
              })
              dialog.show()
            },
            position: loadRenderAngle,
            custom() {
              new Dialog({
                id: "custom_resolution",
                title: "Custom Resolution",
                form: {
                  resolution: {
                    label: "Resolution",
                    type: "number",
                    value: this.resolution,
                    min: 1,
                    max: 4096
                  },
                  info: {
                    type: "info",
                    text: "The resolution determines the width or height of the render, depending on which one is larger. The chosen resolution may not exactly match the render size"
                  },
                  info2: {
                    type: "info",
                    text: "If antialiasing is enabled, the render size is capped at 2048 pixels"
                  }
                },
                onConfirm: result => this.resolution = this.antialias ? Math.min(result.resolution, 2048) : result.resolution
              }).show()
            }
          },
          data: {
            resolution: 1024,
            antialias: true,
            rendering: false
          },
          template: `
            <div id="minecraft-title-render-controls-container">
              <div id="minecraft-title-render-controls">
                <div id="minecraft-title-render-button" @click="render" title="Render Minecraft title" :class="{ disabled: rendering }">
                  <i class="material-icons icon">photo_camera</i>
                </div>
                <div class="minecraft-title-render-controls-row">
                  <i style="margin-left:10px" class="material-icons icon minecraft-title-button" title="Position camera" @click="position">auto_mode</i>
                  <div id="resolutions">
                    <div class="resolution minecraft-title-button" @click="resolution = 480" :class="{ selected: resolution === 480 }" title="Around 480 pixels">
                      <i class="material-icons icon">sd</i>
                    </div>
                    <div class="resolution minecraft-title-button" @click="resolution = 720" :class="{ selected: resolution === 720 }" title="Around 720 pixels">
                      <i class="material-icons icon">hd</i>
                    </div>
                    <div class="resolution minecraft-title-button" @click="resolution = 1024" :class="{ selected: resolution === 1024 }" title="Around 1024 pixels">
                      <svg width="32" height="32" viewBox="0 0 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2M8.808 15h-1.5v-2h-2v2h-1.5V9h1.5v2.5h2V9h1.5v6m.948-6h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-4V9m1.5 4.5h2v-3h-2zm8.937-2.25v1.5h-1.5v1.5h-1.5v-1.5h-1.5v-1.5h1.5v-1.5h1.5v1.5"/></svg>
                    </div>
                    <div class="resolution minecraft-title-button" @click="resolution = 2048" :class="{ selected: resolution === 2048 }" title="Around 2048 pixels">
                      <i class="material-icons icon">2k</i>
                    </div>
                    <div v-if="!antialias" class="resolution minecraft-title-button" @click="resolution = 4096" :class="{ selected: resolution === 4096 }" title="Around 4096 pixels">
                      <i class="material-icons icon">4k</i>
                    </div>
                    <div class="resolution minecraft-title-button" @click="custom" :class="{ selected: ![480, 720, 1024, 2048, 4096].includes(resolution) }" title="Custom size" style="display:flex;align-items:center;justify-content:center">
                      <i style="font-size:24px;margin-left:-3px" class="material-icons icon">tag</i>
                    </div>
                  </div>
                  <div style="margin-right:-20px">Antialiasing:</div>
                  <input type="checkbox" :checked="antialias" v-model="antialias" @input="if (resolution > 2048) resolution = 2048">
                </div>
              </div>
            </div>
          `
        }
      })
      preview = new Preview({
        id: "minecraft_title_preview",
        antialias: false,
        offscreen: true
      })
      dialog = new Dialog({
        id: "new_minecraft_title_text",
        title: "Add Minecraft Title Text",
        buttons: [],
        lines: [`<style>
          #new_minecraft_title_text {
            overflow: hidden;
          }
          #new_minecraft_title_text > .dialog_handle, #new_minecraft_title_text > .dialog_close_button {
            z-index: 3;
          }
          #new_minecraft_title_text .dialog_content {
            margin: 0;
          }
          #minecraft-title-tabs {
            background-color: var(--color-frame);
            display: flex;
            gap: 2px;
            padding: 4px 4px 0;
            position: sticky;
            top: 0;
            z-index: 3;
          }
          #minecraft-title-tabs > div {
            padding: 4px 12px;
            cursor: pointer;
            border-top: 2px solid transparent;
            background-color: var(--color-back);
            flex: 1;
            text-align: center;
          }
          #minecraft-title-tabs > div.selected {
            background-color: var(--color-ui);
            border-top-color: var(--color-accent);
            cursor: default;
          }
          .minecraft-title-contents {
            display: none;
            padding: 20px 20px 0;
            flex-direction: column;
          }
          #minecraft_title_generator .visible {
            display: flex !important;
          }
          #minecraft-title-buttons {
            display: flex;
            padding: 20px 12px 20px 20px;
            gap: 10px;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 8px;
            z-index: 2;
            background-color: var(--color-ui);
          }
          .minecraft-title-contents .slider-label {
            margin: 3px 10px 0 0;
          }
          .minecraft-title-contents .checkbox-row div {
            margin: 3px 0 0 5px;
          }
          .minecraft-title-contents input.hidden + div {
            display: none !important;
          }
          .minecraft-title-contents .checkbox-row {
            display: flex;
            cursor: pointer;
          }
          .minecraft-title-contents .checkbox-row * {
            cursor: pointer;
          }
          .minecraft-title-contents bb-select {
            cursor: pointer;
          }
          #minecraft_title_generator {
            padding-bottom: 72px;
          }
          #minecraft-title-preview-container {
            margin-bottom: -10px;
            position: sticky;
            top: 38px;
            z-index: 2;
            cursor: pointer;
            display: none;
          }
          #minecraft-title-preview {
            width: 100%;
            height: 150px;
            image-rendering: auto;
            object-fit: contain;
          }
          #minecraft-title-preview-container > .icon {
            position: absolute;
            bottom: 7px;
            right: 7px;
          }
          #minecraft-title-preview-container > .fa {
            position: absolute;
            bottom: 3px;
            left: 3px;
            font-size: 18px;
            padding: 6px;
          }
          .minecraft-title-item-buttons {
            position: absolute;
            top: 4px;
            left: 4px;
            font-size: 1.25rem;
            z-index: 1;
            flex-direction: column;
            gap: 3px;
            display: flex;
          }
          .minecraft-title-item-buttons > i {
            display: none;
            font-size: 1.25rem;
          }
          .minecraft-title-item:hover i {
            display: flex !important;
          }
          .minecraft-title-item-author:hover::after {
            content: attr(data-author);
            font-family: var(--font-main);
            position: absolute;
            background-color: var(--color-dark);
            padding: 4px;
            margin: 0 0 0 22px;
            font-size: 0.8em;
            pointer-events: none;
          }
          .minecraft-title-item:nth-child(3n) .minecraft-title-item-author:hover::after {
            transform: translateX(calc(-100% - 25px));
          }
          .minecraft-title-item-buttons > .fa::before {
            font-size: 16px;
            margin-left: 1.25px;
          }
          #minecraft-title-expanded-preview {
            position: absolute;
            inset: 26px 0 0;
            z-index: 29;
            background-color: #0004;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(2px);
            cursor: pointer;
          }
          #minecraft-title-expanded-preview > canvas {
            box-shadow: 0 10px 10px #0004;
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 40px);
          }
          #minecraft_title_generator .sp-replacer {
            display: flex;
            margin-bottom: 10px;
          }
          #minecraft_title_generator .form_inline_select {
            margin: 10px 0;
          }
          .minecraft-title-file > canvas {
            max-height: 160px;
            object-fit: contain;
            cursor: pointer;
          }
          .minecraft-title-file {
            display: flex;
            flex-direction: column;
            gap: 10px;
          }
          #custom-gradient-customiser {
            display: flex;
            gap: 5px;
          }
          #gradient-preview {
            flex: 1;
            height: 160px;
          }
          .minecraft-title-file.hidden, #custom-gradient.hidden {
            display: none;
          }
          #gradient-colours {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
          }
          #gradient-colours > div {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
          }
          #gradient-colours .sp-replacer {
            margin-bottom: 0;
          }
          #gradient-colours .sp-preview {
            width: 50px;
          }
          #gradient-colours input.disabled + div {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
          }
          #gradient-colours input.disabled + div .sp-preview::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(to top right, transparent calc(50% - 2px), var(--color-close) calc(50% - 1px) calc(50% + 1px), transparent calc(50% + 2px)), linear-gradient(to top left, transparent calc(50% - 2px), var(--color-close) calc(50% - 1px) calc(50% + 1px), transparent calc(50% + 2px));
          }
          #gradient-colours input.disabled + div .sp-preview-inner {
            filter: grayscale(1);
          }
          .minecraft-title-header-row {
            display: flex;
            justify-content: space-between;
            align-items: end;
          }
          .github-link, .github-link > a {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
            align-items: center;
            text-decoration: none;
          }
          .github-link > a:hover > div {
            text-decoration: underline;
            cursor: pointer;
          }
          #minecraft-title-custom-texture {
            position: relative;
          }
          #minecraft-title-custom-texture > i {
            position: absolute;
            top: 7px;
            right: 7px;
            cursor: pointer;
          }
          #text-type-input {
            text-decoration: none;
          }
          body:has(#text-type-input:focus) > .contextMenu > li > span::after {
            opacity: 0.8;
            font-size: 12px;
          }
          body:has(#text-type-input:focus) > .contextMenu > li:first-child > span::after {
            content: 'The "Minecraft" text';
            margin-left: 35px;
          }
          body:has(#text-type-input:focus) > .contextMenu > li:nth-child(2) > span::after {
            content: 'The update text';
            margin-left: 10px;
          }
          body:has(#text-type-input:focus) > .contextMenu > li:last-child > span::after {
            content: 'The edition text';
            margin-left: 22px;
          }
          #new_minecraft_title_text .dialog_close_button:nth-child(2):hover {
            background-color: var(--color-accent);
          }
          .minecraft-texture-search {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            position: relative;
          }
          .minecraft-texture-search > input {
            flex: 1;
            padding-right: 30px;
          }
          .minecraft-texture-search > i {
            position: absolute;
            right: 6px;
            top: 5px;
            pointer-events: none;
          }
          .text-input-row {
            display: flex;
            gap: 10px;
            align-items: center;
          }
          .text-input-row > input {
            flex: 1;
          }
          #minecraft-title-connection-warning {
            background-color: var(--color-frame);
            padding: 10px;
          }
          #minecraft-title-connection-warning * {
            cursor: pointer;
          }
          #minecraft-title-connection-warning > div {
            border: 1px solid var(--color-warning);
            border-radius: 10px;
            padding: 5px 10px;
            position: relative;
            z-index: 0;
            overflow: hidden;
            color: var(--color-light);
            display: flex;
            align-items: center;
            gap: 10px;
          }
          #minecraft-title-connection-warning > div::before {
            content: "";
            position: absolute;
            inset: 0;
            background-color: var(--color-warning);
            z-index: -1;
            opacity: 0.25;
          }
          #minecraft-title-connection-warning > div > svg {
            fill: var(--color-light);
          }
          #minecraft-title-connection-warning-underline {
            text-decoration: underline;
          }
          .tileable-preview {
            width: calc(100% - 34px);
            min-height: 48px;
            overflow: hidden;
          }
          .tileable-preview > div {
            scale: 3;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
          }
          .radio-row {
            display: flex;
            align-items: center;
            gap: 20px !important;
          }
          .radio-row > label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
          }
          .radio-row > label * {
            cursor: pointer;
          }
          .minecraft-title-button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
          }
          .minecraft-title-button-row > button {
            flex: 1;
            min-height: 32px;
            height: initial;
            line-height: 110%;
            padding-top: 6px;
            padding-bottom: 6px;
          }
        </style>`],
        component: {
          data: {
            connection,
            tab: 0,
            text: "",
            font: Object.keys(fonts)[0],
            baseFont: Object.keys(fonts)[0],
            fontTab: "fonts",
            fontVariant: null,
            fonts,
            fontList: [],
            textType: "top",
            textTypes: {
              "top": 'Top',
              "bottom": "Bottom",
              "small": "Small"
            },
            row: 0,
            texture: Object.keys(fonts["minecraft-ten"].textures)[1] ?? Object.keys(fonts["minecraft-ten"].textures)[0],
            textures: [],
            tileable: Object.keys(tileables)[0],
            tileables,
            tileablesList: [],
            overlay: Object.keys(fonts["minecraft-ten"].overlays)[0],
            overlays: [],
            variant: null,
            tileableVariant: null,
            hue: 0,
            saturation: 100,
            brightness: 100,
            contrast: 100,
            colour: "#fff",
            customBorderColour: "#000",
            customEdgeColour: "#000",
            gradientColour0: "#FFCF76",
            gradientColour1: "#FFA3A3",
            gradientColour2: "#F4C1A4",
            gradientColour3: "#E19A3E",
            gradientColour4: "#DA371E",
            overlayColour: "#fff",
            blend: "multiply",
            blends: {
              multiply: "Multiply",
              color: "Colour",
              lighter: "Lighter",
              screen: "Screen",
              overlay: "Overlay",
              "soft-light": "Soft Light",
              hue: "Hue",
              saturation: "Saturation",
              difference: "Difference",
              "source-over": "Source Over"
            },
            customBorder: false,
            fadeToBorder: false,
            characterSpacing: 0,
            rowSpacing: 0,
            scaleX: 1,
            scaleY: 1,
            scaleZ: 1,
            building: false,
            build: false,
            updating: false,
            update: false,
            terminators: false,
            customEdge: false,
            textureSource: "premade",
            overlaySource: "premade",
            gradientColour1Enabled: false,
            gradientColour2Enabled: false,
            gradientColour3Enabled: false,
            overlayBlend: "overlay",
            overlayColourBlend: "multiply",
            customTexture: null,
            customTextureType: "texture",
            smoothGradient: true,
            lastTextureSource: null,
            textureSearch: "",
            colourOpacity: 100,
            overlayOpacity: 100,
            tileableScale: 2,
            tileableXOffset: 0,
            tileableYOffset: 0,
            tileableWidth: 0,
            tileableHeight: 0,
            tileableRandomRotations: false,
            tileableRandomMirroring: false,
            tileableTextureResolution: 1000,
            edgeBrightness: 35
          },
          mounted() {
            $(this.$refs.colour).spectrum(colourInput(dialog, "colour")),
            $(this.$refs.customBorderColour).spectrum(colourInput(dialog, "customBorderColour")),
            $(this.$refs.customEdgeColour).spectrum(colourInput(dialog, "customEdgeColour")),
            $(this.$refs.gradientColour0).spectrum(colourInput(dialog, "gradientColour0")),
            $(this.$refs.gradientColour1).spectrum(colourInput(dialog, "gradientColour1")),
            $(this.$refs.gradientColour2).spectrum(colourInput(dialog, "gradientColour2")),
            $(this.$refs.gradientColour3).spectrum(colourInput(dialog, "gradientColour3")),
            $(this.$refs.gradientColour4).spectrum(colourInput(dialog, "gradientColour4")),
            $(this.$refs.overlayColour).spectrum(colourInput(dialog, "overlayColour"))
          },
          methods: {
            async reset(force, ignoreUpdate) {
              if (force || this.tab === 0) {
                if (this.font !== Object.keys(fonts)[0]) {
                  this.font = Object.keys(fonts)[0]
                  await this.updateFont(ignoreUpdate)
                }
                this.textType = "top"
                this.row = 0
              }
              if (force || this.tab === 1) {
                this.texture = Object.keys(fonts[this.font].textures)[1] ?? Object.keys(fonts[this.font].textures)[0]
                this.variant = null
                this.tileable = Object.keys(tileables)[0]
                this.tileableVariant = null
                this.textureSource = "premade"
                this.gradientColour1Enabled = false
                this.gradientColour2Enabled = false
                this.gradientColour3Enabled = false
                this.smoothGradient = true
                this.gradientColour0 = "#FFCF76"
                this.gradientColour1 = "#FFA3A3"
                this.gradientColour2 = "#F4C1A4"
                this.gradientColour3 = "#E19A3E"
                this.gradientColour4 = "#DA371E"
                this.customTexture = null
                this.customTextureType = "texture"
                $(this.$refs.gradientColour0).spectrum("set", "#FFCF76")
                $(this.$refs.gradientColour1).spectrum("set", "#FFA3A3")
                $(this.$refs.gradientColour2).spectrum("set", "#F4C1A4")
                $(this.$refs.gradientColour3).spectrum("set", "#E19A3E")
                $(this.$refs.gradientColour4).spectrum("set", "#DA371E")
              }
              if (force || this.tab === 2) {
                this.overlaySource = "premade"
              }
              if (force || this.tab === 3) {
                this.terminators = false
              }
              if (force || this.tab === 4) {
                this.characterSpacing = 0
                this.rowSpacing = 0
                this.scaleX = 1
                this.scaleY = 1
                this.scaleZ = 1
              }
              this.resetTexture(force)
              if (!ignoreUpdate) this.buildPreview()
            },
            resetTexture(force) {
              if (force || this.tab === 2) {
                this.overlay = Object.keys(fonts["minecraft-ten"].overlays)[0]
                this.overlayBlend = "overlay"
                this.overlayColourBlend = "multiply"
                this.overlayOpacity = 100
                this.overlayColour = "#fff"
                $(this.$refs.overlayColour).spectrum("set", "#fff")
              }
              if (force || this.tab === 3) {
                this.tileableScale = 2
                this.tileableXOffset = 0
                this.tileableYOffset = 0
                this.tileableRandomRotations = false
                this.tileableRandomMirroring = false
                this.tileableTextureResolution = 1000
                this.hue = 0
                this.saturation = 100
                this.brightness = 100
                this.contrast = 100
                this.blend = "multiply"
                this.customBorder = false
                this.fadeToBorder = false
                this.customEdge = false
                this.colourOpacity = 100
                this.colour = "#fff"
                this.customBorderColour = "#000"
                this.customEdgeColour = "#000"
                $(this.$refs.colour).spectrum("set", "#fff")
                $(this.$refs.customBorderColour).spectrum("set", "#000")
                $(this.$refs.customEdgeColour).spectrum("set", "#000")
              }
            },
            finish: () => dialog.onConfirm(),
            async updateFont(ignoreUpdate) {
              await getFontTextures(this.font)
              if (!this.textures.find(e => e[0] === "flat" && e[2] === this.font)) {
                const textures = Object.entries(fonts[this.font].textures).map(e => e.concat([this.font]))
                const overlays = Object.entries(fonts[this.font].overlays).map(e => e.concat([this.font]))
                textures.sort((a, b) => {
                  const statsA = stats.find(e => e.id === `${a[2]}.${a[0]}`)?.count ?? 0
                  const statsB = stats.find(e => e.id === `${a[2]}.${b[0]}`)?.count ?? 0
                  return statsB - statsA
                })
                overlays.sort((a, b) => {
                  const statsA = stats.find(e => e.id === `${a[2]}.${a[0]}`)?.count ?? 0
                  const statsB = stats.find(e => e.id === `${a[2]}.${b[0]}`)?.count ?? 0
                  return statsB - statsA
                })
                this.textures.push(...textures)
                this.overlays.push(...overlays)
              }
              this.texture = Object.keys(fonts[this.font].textures)[1] ?? Object.keys(fonts[this.font].textures)[0]
              this.overlay = Object.keys(fonts[this.font].overlays)[0]
              if (!ignoreUpdate) this.buildPreview()
            },
            buildPreview() {
              let finish
              setTimeout(async () => {
                if (this.building) {
                  this.build = true
                  finish()
                  return
                }
                this.building = true
                await this.makePreview()
                this.building = false
                if (this.build) {
                  this.update = false
                  await this.buildPreview()
                }
                finish()
              }, 0)
              return new Promise(fulfil => finish = fulfil)
            },
            async makePreview() {
              this.scene.remove(...this.scene.children)

              const texture = await makeTexture(getArgs(this, true))

              this.material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.5
              })
              
              await getFontCharacters(this.font)

              const addText = (str, args) => {
                let width = 0
                const cubes = []
                const group = new THREE.Group()
                for (const char of str) {
                  if (char === " ") {
                    width += 8
                    continue
                  }
                  let min = Infinity
                  let max = -Infinity
                  const character = new THREE.Group()
                  for (let cube of fonts[this.font].characters[char]) {
                    if (!cube.parsed) {
                      cube.parsed = true
                      for (const [direction, uv] of Object.entries(cube.faces)) {
                        cube.faces[direction] = { uv }
                      }
                    }

                    cube = JSON.parse(JSON.stringify(cube))
                    min = Math.min(min, cube.from[0], cube.to[0])
                    max = Math.max(max, cube.from[0], cube.to[0])

                    if (args.type === "bottom" && !fonts[this.font].flat) {
                      if (cube.to[2] > cube.from[2]) {
                        cube.to[2] += 20
                      } else {
                        cube.from[2] += 20
                      }
                    }

                    const geometry = new THREE.BoxGeometry(cube.to[0] - cube.from[0], cube.to[1] - cube.from[1], cube.to[2] - cube.from[2])
                    const mesh = new THREE.Mesh(geometry, this.material)

                    mesh.position.fromArray([
                      (cube.from[0] + cube.to[0]) / 2,
                      (cube.from[1] + cube.to[1]) / 2,
                      (cube.from[2] + cube.to[2]) / 2
                    ])

                    const indexes = {
                      north: 40,
                      east: 0,
                      south: 32,
                      west: 8,
                      up: 16,
                      down: 24
                    }

                    for (const key of Object.keys(indexes)) {
                      const face = cube.faces[key]
                      const i = indexes[key]
                      if (face) {
                        const uv = [
                          [face.uv[0] / 16, 1 - (face.uv[1] / 16)],
                          [face.uv[2] / 16, 1 - (face.uv[1] / 16)],
                          [face.uv[0] / 16, 1 - (face.uv[3] / 16)],
                          [face.uv[2] / 16, 1 - (face.uv[3] / 16)]
                        ]
                        mesh.geometry.attributes.uv.array.set(uv[0], i + 0)
                        mesh.geometry.attributes.uv.array.set(uv[1], i + 2)
                        mesh.geometry.attributes.uv.array.set(uv[2], i + 4)
                        mesh.geometry.attributes.uv.array.set(uv[3], i + 6)
                      } else {
                        mesh.geometry.attributes.uv.array.set([1, 1], i + 0)
                        mesh.geometry.attributes.uv.array.set([1, 1], i + 2)
                        mesh.geometry.attributes.uv.array.set([1, 1], i + 4)
                        mesh.geometry.attributes.uv.array.set([1, 1], i + 6)
                      }
                    }
                    character.add(mesh)
                    cubes.push(mesh)
                  }
                  for (const cube of character.children) {
                    cube.position.x -= width + max
                  }
                  group.add(character)
                  width += max - min
                }

                for (const cube of cubes) {
                  cube.position.x += width / 2
                }

                if (fonts[this.font].autoBorder) {
                  let minX = Infinity
                  let minY = Infinity
                  let minZ = Infinity
                  let maxX = -Infinity
                  let maxY = -Infinity
                  let maxZ = -Infinity

                  for (const cube of cubes) {
                    const from = [
                      cube.position.x - cube.geometry.parameters.width / 2,
                      cube.position.y - cube.geometry.parameters.height / 2,
                      cube.position.z - cube.geometry.parameters.depth / 2
                    ]
                    const to = [
                      from[0] + cube.geometry.parameters.width,
                      from[1] + cube.geometry.parameters.height,
                      from[2] + cube.geometry.parameters.depth
                    ]
                    minX = Math.min(minX, from[0], to[0])
                    minY = Math.min(minY, from[1], to[1])
                    minZ = Math.min(minZ, from[2], to[2])
                    maxX = Math.max(maxX, from[0], to[0])
                    maxY = Math.max(maxY, from[1], to[1])
                    maxZ = Math.max(maxZ, from[2], to[2])
                  }

                  const geometry = new THREE.BoxGeometry(minX - maxX - 4, minY - maxY - 4, minZ - maxZ - 4)
                  const mesh = new THREE.Mesh(geometry, this.material)

                  mesh.position.fromArray([
                    (maxX + minX) / 2,
                    (maxY + minY) / 2,
                    (maxZ + minZ) / 2
                  ])

                  const indexes = [40, 0, 32, 8, 16, 24]

                  for (const i of indexes) {
                    const uv = [
                      [0, 1 - fonts[this.font].border / 320],
                      [1 / 1000, 1 - fonts[this.font].border / 320],
                      [0, 1 - (fonts[this.font].border + 1) / 320],
                      [1 / 1000, 1 - (fonts[this.font].border + 1) / 320]
                    ]
                    mesh.geometry.attributes.uv.array.set(uv[0], i + 0)
                    mesh.geometry.attributes.uv.array.set(uv[1], i + 2)
                    mesh.geometry.attributes.uv.array.set(uv[2], i + 4)
                    mesh.geometry.attributes.uv.array.set(uv[3], i + 6)
                  }

                  group.add(mesh)
                }

                if (args.type === "bottom") {
                  group.scale.setX(0.75)
                  group.scale.setY(1.6)
                  group.scale.setZ(0.75)
                  group.rotation.fromArray([Math.degToRad(-90), 0, 0])
                  group.position.z += fonts[this.font].height + 49
                  if (fonts[this.font].flat) {
                    group.position.y -= 18
                  } else {
                    group.position.y -= 25 - fonts[this.font].ends[0][1]
                  }
                }

                this.scene.add(group)
              }

              if ((this.terminators || fonts[this.font].forcedTerminators) && fonts[this.font].terminatorSpace) {
                addText(`â”« ${fonts[this.font].example?.[0] ?? "exðŸ˜³mple"} â”£`, {})
                addText(`â”« ${fonts[this.font].example?.[1] ?? "text"} â”£`, { type: "bottom" })
              } else if (this.terminators || fonts[this.font].forcedTerminators) {
                addText(`â”«${fonts[this.font].example?.[0] ?? "exðŸ˜³mple"}â”£`, {})
                addText(`â”«${fonts[this.font].example?.[1] ?? "text"}â”£`, { type: "bottom" })
              } else {
                addText(fonts[this.font].example?.[0] ?? "exðŸ˜³mple", {})
                addText(fonts[this.font].example?.[1] ?? "text", { type: "bottom" })
              }

              this.renderer = new THREE.WebGLRenderer({
                alpha: true,
                canvas: this.canvas,
                preserveDrawingBuffer: true
              })

              this.renderer.render(this.scene, this.camera)
            },
            updatePreview() {
              setTimeout(async () => {
                if (this.updating) {
                  this.update = true
                  return
                }
                this.updating = true
                const texture = await makeTexture(getArgs(this, true))
                this.material.map = texture
                this.material.needsUpdate = true
                this.renderer.render(this.scene, this.camera)
                if (this.textureSource === "tileable" || this.textureSource === "file" && this.customTexture && this.customTextureType === "tileable") {
                  let img
                  if (this.textureSource === "file") img = await loadImage(this.customTexture)
                  else img = await loadImage(await getTileable(this.tileable, this.tileableVariant))
                  this.tileableWidth = img.width - 1
                  this.tileableHeight = img.height - 1
                  this.tileableXOffset = Math.min(this.tileableXOffset, img.width - 1)
                  this.tileableYOffset = Math.min(this.tileableYOffset, img.height - 1)
                }
                this.updating = false
                if (this.update) {
                  this.update = false
                  this.updatePreview()
                }
              }, 0)
            },
            expandCanvas(e) {
              const canvas = new CanvasFrame(this.canvas.width, this.canvas.height)
              canvas.canvas.classList.add("checkerboard")
              canvas.ctx.drawImage(this.canvas, 0, 0)
              const overlay = document.createElement("div")
              overlay.id = "minecraft-title-expanded-preview"
              overlay.append(canvas.canvas)
              overlay.addEventListener("click", e => overlay.remove())
              document.body.append(overlay)
            },
            async selectCustomTexture() {
              const texture = await getTextureFromFile()
              if (!texture) return
              if (texture.width / texture.height === 3.125) this.customTextureType = "texture"
              else this.customTextureType = "tileable"
              globalThis.texture = texture
              this.customTextureCanvas.width = texture.width
              this.customTextureCanvas.height = texture.height
              this.customTextureCanvas.getContext("2d").drawImage(texture, 0, 0, this.customTextureCanvas.width, this.customTextureCanvas.height)
              this.customTexture = this.customTextureCanvas.toDataURL()
              this.updatePreview()
            },
            async selectCustomOverlay() {
              const texture = await getTextureFromFile()
              if (!texture) return
              this.customOverlayCanvas.width = texture.width
              this.customOverlayCanvas.height = texture.height
              this.customOverlayCanvas.getContext("2d").drawImage(texture, 0, 0, this.customOverlayCanvas.width, this.customOverlayCanvas.height)
              this.customOverlay = this.customOverlayCanvas.toDataURL()
              this.updatePreview()
            },
            deleteCustomTexture() {
              this.customTexture = null
              this.customTextureCanvas.getContext("2d").clearRect(0, 0, this.customTextureCanvas.width, this.customTextureCanvas.height)
              this.updatePreview()
            },
            saveTexture: async (font, type, texture, variant) => Blockbench.export({
              type: "PNG Texture",
              extensions: ["png"],
              name: variant ?? texture,
              content: type === "tileables" ? await getTileable(texture, variant) : await getTexture(fonts[font][type], texture, variant),
              savetype: "image"
            }, () => {
              Blockbench.showQuickMessage("Exported texture")
              sendStats({
                font,
                texture: type === "textures" ? texture : undefined,
                tileable: type === "tileables" ? texture : undefined,
                overlay: type === "overlays" ? texture : undefined
              })
            }),
            async importTexture() {
              const textures = []
              Undo.initEdit({ textures })
              const args = getArgs(this)
              args.text = args.customTexture ? "custom" : this.textureSource === "gradient" ? "gradient" : this.texture
              const texture = await makeTexture(args)
              texture.add()
              textures.push(texture)
              Undo.finishEdit("Add Minecraft title texture")
              dialog.close()
              sendStats(args)
            },
            scrollToVariants() {
              setTimeout(() => {
                if (this.$refs.textureVariants) {
                  this.$refs.textureVariants.scrollIntoView({ behavior: "smooth" })
                }
              }, 0)
            },
            importTextureAsFile() {
              Blockbench.showMessageBox({
                title: "Import current texture as file",
                message: "Are you sure you want to import the current texture as a file?\n\nAny settings applied to it will be baked into the texture and cannot be removed.\n\nThis action cannot be undone.",
                buttons: ["dialog.confirm", "dialog.cancel"]
              }, async button => {
                if (button === 0) {
                  const args = getArgs(this)
                  sendStats(args)
                  args.canvas = true
                  const texture = await makeTexture(args)
                  this.customTextureCanvas.width = texture.width
                  this.customTextureCanvas.height = texture.height
                  this.customTextureCanvas.getContext("2d").drawImage(texture, 0, 0, this.customTextureCanvas.width, this.customTextureCanvas.height)
                  this.customTexture = texture.toDataURL()
                  this.resetTexture(true)
                  this.updatePreview()
                }
              })
            },
            presets() {
              const settings = this
              const presetDialog = new Dialog({
                id: "minecraft_title_presets",
                title: "Minecraft Title Presets",
                buttons: [],
                lines: [`<style>
                  #minecraft_title_presets .dialog_content {
                    margin: 20px;
                  }
                  #minecraft-title-presets-container {
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                  }
                  .minecraft-title-preset {
                    display: flex;
                    gap: 10px;
                    padding: 10px 15px;
                    align-items: center;
                    cursor: pointer;
                  }
                  .minecraft-title-preset:hover {
                    background-color: var(--color-accent);
                    color: var(--color-accent_text);
                  }
                  .minecraft-title-preset > i:hover {
                    color: var(--color-ui);
                  }
                  .minecraft-title-preset-name {
                    font-size: 1.5rem;
                  }
                  .minecraft-title-preset-date {
                    margin-top: 4px;
                    opacity: 0.75;
                    font-size: 0.8rem;
                  }
                  #minecraft-title-preset-buttons {
                    display: flex;
                    gap: 10px;
                  }
                  #minecraft-title-preset-buttons > button {
                    flex: 1;
                  }
                </style>`],
                component: {
                  data: {
                    presets: JSON.parse(localStorage.getItem("minecraft_title_presets") ?? "{}")
                  },
                  methods: {
                    add() {
                      const args = getArgs(settings)
                      args.textureSource = settings.textureSource
                      args.overlaySource = settings.overlaySource
                      if (args.textureSource === "file" || args.overlaySource === "file") {
                        return Blockbench.showQuickMessage("Custom textures are not supported for presets", 3000)
                      }
                      const filtered = Object.fromEntries(Object.entries(args).filter(e => e[1] !== null && e[1] !== false))
                      for (const [key, obj] of Object.entries(this.presets)) {
                        if (areObjectsEqual(filtered, obj.settings)) {
                          return Blockbench.showQuickMessage(`Current settings are already saved under the preset "${key}"`, 3000)
                        }
                      }
                      new Dialog({
                        id: "minecraft_title_preset_name",
                        title: "Minecraft Title Preset Name",
                        form: {
                          name: {
                            label: "Preset Name",
                            placeholder: "Minecraft Cracked"
                          }
                        },
                        onConfirm: result => {
                          const name = result.name.trim()
                          if (!name) return Blockbench.showQuickMessage("No name provided")
                          if (name.length > 24) return Blockbench.showQuickMessage("Please keep names 24 characters or less", 3000)
                          if (this.presets[name]) return Blockbench.showQuickMessage(`The name "${name}" is already in use`, 3000)
                          this.presets[name] = {
                            date: Date.now(),
                            settings: filtered
                          }
                          localStorage.setItem("minecraft_title_presets", JSON.stringify(this.presets))
                          this.$forceUpdate()
                        }
                      }).show()
                    },
                    deletePreset(event, name) {
                      Blockbench.showMessageBox({
                        title: "Delete preset",
                        message: `Are you sure you want to delete the preset "${name}"?\n\nThis action cannot be undone.`,
                        buttons: ["dialog.confirm", "dialog.cancel"]
                      }, async button => {
                        if (button === 0) {
                          delete this.presets[name]
                          localStorage.setItem("minecraft_title_presets", JSON.stringify(this.presets))
                          this.$forceUpdate()
                          Blockbench.showQuickMessage("Deleted preset")
                        }
                      })
                    },
                    async load(event, name) {
                      if (event.target.classList.contains("material-icons")) return
                      settings.reset(true, true)
                      const args = this.presets[name].settings
                      if (fonts[args.font]) {
                        settings.font = args.font
                        await settings.updateFont(true)
                        if (fonts[args.font].textures[args.texture]) {
                          settings.texture = args.texture
                          if (args.variant && fonts[args.font].textures[args.texture].variants?.[args.variant]) {
                            settings.variant = args.variant
                          }
                        }
                        if (fonts[args.font].overlays[args.overlay]) {
                          settings.overlay = args.overlay
                        }
                      }
                      if (fonts[args?.baseFont]) settings.baseFont = args.baseFont
                      if (fonts[args?.fontVariant]) settings.fontVariant = args.fontVariant
                      if (args.type) settings.textType = args.type
                      if (args.row) settings.row = args.row
                      if (args.textureSource) settings.textureSource = args.textureSource
                      if (args.tileable && tileables[args.tileable]) {
                        settings.tileable = args.tileable
                        if (args.tileableVariant && tileable[args.tileable].variants?.[args.tileableVariant]) {
                          settings.tileableVariant = args.tileableVariant
                        }
                        if (args.tileableXOffset || args.tileableYOffset) {
                          const img = await loadImage(await getTileable(args.tileable, args.tileableVariant))
                          if (args.tileableXOffset) settings.tileableXOffset = Math.min(img.width - 1, args.tileableXOffset)
                          if (args.tileableYOffset) settings.tileableYOffset = Math.min(img.height - 1, args.tileableYOffset)
                        }
                      }
                      if (args.tileableVariant) settings.tileableVariant = args.tileableVariant
                      if (args.overlaySource) settings.overlaySource = args.overlaySource
                      if (args.gradientColour1Enabled) settings.gradientColour1Enabled = args.gradientColour1Enabled
                      if (args.gradientColour2Enabled) settings.gradientColour2Enabled = args.gradientColour2Enabled
                      if (args.gradientColour3Enabled) settings.gradientColour3Enabled = args.gradientColour3Enabled
                      if (args.smoothGradient) settings.smoothGradient = true
                      if (args.gradientColour0) {
                        settings.gradientColour0 = args.gradientColour0
                        $(settings.$refs.gradientColour0).spectrum("set", args.gradientColour0)
                      }
                      if (args.gradientColour1) {
                        settings.gradientColour1 = args.gradientColour1
                        $(settings.$refs.gradientColour1).spectrum("set", args.gradientColour1)
                      }
                      if (args.gradientColour2) {
                        settings.gradientColour2 = args.gradientColour2
                        $(settings.$refs.gradientColour2).spectrum("set", args.gradientColour2)
                      }
                      if (args.gradientColour3) {
                        settings.gradientColour3 = args.gradientColour3
                        $(settings.$refs.gradientColour3).spectrum("set", args.gradientColour3)
                      }
                      if (args.gradientColour4) {
                        settings.gradientColour4 = args.gradientColour4
                        $(settings.$refs.gradientColour4).spectrum("set", args.gradientColour4)
                      }
                      if (args.terminators) settings.terminators = args.terminators
                      if (args.characterSpacing) settings.characterSpacing = args.characterSpacing
                      if (args.rowSpacing) settings.rowSpacing = args.rowSpacing
                      if (args.scale) {
                        settings.scaleX = args.scale[0]
                        settings.scaleY = args.scale[1]
                        settings.scaleZ = args.scale[2]
                      }
                      if (args.overlayBlend) settings.overlayBlend = args.overlayBlend
                      if (args.overlayColourBlend) settings.overlayColourBlend = args.overlayColourBlend
                      if (args.overlayOpacity !== undefined) settings.overlayOpacity = args.overlayOpacity
                      if (args.colourOpacity !== undefined) settings.colourOpacity = args.colourOpacity
                      if (args.tileableScale !== undefined) settings.tileableScale = args.tileableScale
                      if (args.tileableRandomRotations) settings.tileableRandomRotations = true
                      if (args.tileableRandomMirroring) settings.tileableRandomMirroring = true
                      if (args.tileableTextureResolution) settings.tileableTextureResolution = args.tileableTextureResolution
                      if (args.hue) settings.hue = args.hue
                      if (args.saturation !== undefined) settings.saturation = args.saturation
                      if (args.brightness !== undefined) settings.brightness = args.brightness
                      if (args.contrast !== undefined) settings.contrast = args.contrast
                      if (args.blend) settings.blend = args.blend
                      if (args.customBorder) settings.customBorder = true
                      if (args.fadeToBorder) settings.fadeToBorder = true
                      if (args.customEdge) settings.customEdge = true
                      if (args.edgeBrightness !== undefined) settings.edgeBrightness = args.edgeBrightness
                      if (args.colour) {
                        settings.colour = args.colour
                        $(settings.$refs.colour).spectrum("set", args.colour)
                      }
                      if (args.customBorderColour) {
                        settings.customBorderColour = args.customBorderColour
                        $(settings.$refs.customBorderColour).spectrum("set", args.customBorderColour)
                      }
                      if (args.customEdgeColour) {
                        settings.customEdgeColour = args.customEdgeColour
                        $(settings.$refs.customEdgeColour).spectrum("set", args.customEdgeColour)
                      }
                      if (args.overlayColour) {
                        settings.overlayColour = args.overlayColour
                        $(settings.$refs.overlayColour).spectrum("set", args.overlayColour)
                      }
                      settings.buildPreview().then(settings.updatePreview)
                      globalThis.testtest = settings
                      presetDialog.close()
                      Blockbench.showQuickMessage(`Preset "${name}" loaded`, 3000)
                    },
                    importText(name, text) {
                      new Dialog({
                        id: "minecraft_title_preset_import",
                        title: "Minecraft Title Preset Import",
                        form: {
                          name: {
                            label: "Preset Name",
                            placeholder: "Minecraft Cracked",
                            value: name
                          },
                          data: {
                            type: "textarea",
                            label: "Preset Data",
                            placeholder: "{}",
                            value: text
                          }
                        },
                        onConfirm: result => {
                          const name = result.name.trim()
                          if (!name) return Blockbench.showQuickMessage("No name provided")
                          if (name.length > 24) return Blockbench.showQuickMessage("Please keep names 24 characters or less", 3000)
                          if (this.presets[name]) return Blockbench.showQuickMessage(`The name "${name}" is already in use`, 3000)
                          try {
                            const data = JSON.parse(result.data.trim())
                            if (!data.preset || data.type !== "minecraft_title_generator_preset") {
                              return Blockbench.showQuickMessage("Invalid preset")
                            }
                            for (const [key, obj] of Object.entries(this.presets)) {
                              if (areObjectsEqual(data.preset, obj.settings)) {
                                return Blockbench.showQuickMessage(`Current settings are already saved under the preset "${key}"`, 3000)
                              }
                            }
                            this.presets[name] = {
                              date: Date.now(),
                              settings: data.preset
                            }
                            localStorage.setItem("minecraft_title_presets", JSON.stringify(this.presets))
                            this.$forceUpdate()
                          } catch {
                            Blockbench.showQuickMessage("Invalid json for preset data", 3000)
                          }
                        }
                      }).show()
                    },
                    importFile() {
                      Blockbench.import({
                        extensions: ["json"],
                        type: "Minecraft Title Preset",
                      }, files => {
                        this.importText(files[0].name.replace(/\.json$/, ""), files[0].content)
                      })
                    },
                    exportPreset(event, name) {
                      const dialog = new Dialog({
                        id: "minecraft_title_preset_export",
                        title: "Minecraft Title Preset Export",
                        buttons: [],
                        lines: [`<style>
                          #minecraft_title_preset_export .dialog_content {
                            margin: 20px;
                          }
                          #minecraft-title-preset-export {
                            display: flex;
                            flex-direction: column;
                            gap: 20px;
                          }
                          #minecraft-title-preset-export-text {
                            background-color: var(--color-back);
                            padding: 10px;
                            border: 1px solid var(--color-border);
                            cursor: text;
                            user-select: all;
                            word-break: break-all;
                            max-height: 256px;
                            overflow-y: auto;
                          }
                          #minecraft-title-preset-export-buttons {
                            display: flex;
                            gap: 10px;
                          }
                          #minecraft-title-preset-export-buttons > button {
                            flex: 1;
                          }
                        </style>`],
                        component: {
                          data: {
                            preset: {
                              type: "minecraft_title_generator_preset",
                              version: 1,
                              preset: this.presets[name].settings
                            }
                          },
                          methods: {
                            copy() {
                              navigator.clipboard.writeText(JSON.stringify(this.preset))
                              Blockbench.showQuickMessage("Copied to clipboard")
                              dialog.close()
                            },
                            save() {
                              Blockbench.export({
                                extensions: ["json"],
                                name: `${name.replace(/\s/g, "_")}.json`,
                                content: JSON.stringify(this.preset, null, 2)
                              }, () => {
                                Blockbench.showQuickMessage("Exported preset")
                                dialog.close()
                              })
                            }
                          },
                          template: `
                            <div id="minecraft-title-preset-export">
                              <div id="minecraft-title-preset-export-text">{{ JSON.stringify(preset) }}</div>
                              <div id="minecraft-title-preset-export-buttons">
                                <button @click="copy">Copy</button>
                                <button @click="save">Export</button>
                              </div>
                            </div>
                          `
                        }
                      }).show()
                    }
                  },
                  template: `
                    <div id="minecraft-title-presets-container">
                      <div v-if="Object.keys(this.presets).length" id="minecraft-title-presets">
                        <div v-for="[name, data] of Object.entries(presets)" class="minecraft-title-preset" @click="load(event, name)">
                          <div class="minecraft-title-preset-name">{{ name }}</div>
                          <div class="minecraft-title-preset-date">{{ new Date(data.date).toLocaleString() }}</div>
                          <div class="spacer"></div>
                          <i class="material-icons" @click="exportPreset(event, name)" title="Share preset">ios_share</i>
                          <i class="material-icons" @click="deletePreset(event, name)" title="Delete preset">delete</i>
                        </div>
                      </div>
                      <button @click="add">Create new preset</button>
                      <div id="minecraft-title-preset-buttons">
                        <button @click="importText()" title="Import preset">Import from text</button>
                        <button @click="importFile" title="Import preset">Import from file</button>
                      </div>
                    </div>
                  `
                }
              }).show()
            },
            textInfo(font, parent) {
              new Blockbench.Dialog({
                id: "minecraft_title_info",
                title: `${parent && parent !== font ? `${fonts[parent].name} ` : ""}${fonts[font].name} Info`,
                lines: [`<style>
                  #minecraft_title_info .code, #minecraft_title_info code {
                    padding: 0 2px;
                    border: 1px solid var(--color-border);
                    background-color: var(--color-back);
                    cursor: text;
                    user-select: text;
                  }
                </style>`],
                component: { template: `
                  <div>
                    ${fonts[font].description ? `<p>${fonts[font].description.replace(/`(.*?)`/g, "<code>$1</code>")}</p>` : ""}
                    <h2>Available Characters</h2>
                    <div class="code">${Object.keys(fonts[font].characters).sort((a, b) => {
                      const isALetter = /[a-zA-Z]/.test(a)
                      const isBLetter = /[a-zA-Z]/.test(b)
                      const isANumber = /\d/.test(a)
                      const isBNumber = /\d/.test(b)
                      if (isALetter) {
                        if (!isBLetter) return -1
                        else if (isBLetter)
                        return a.localeCompare(b)
                      } else if (isANumber) {
                        if (!isBLetter && !isBNumber) return -1
                        else if (isBLetter) return 1
                        else if (isBNumber) return a.localeCompare(b)
                      } else {
                        if (isBLetter || isBNumber) return 1
                        else return a.localeCompare(b)
                      }
                    }).join(" ").replace(/[ðŸ˜©ðŸ˜³]/g, "")}</div>
                    <p style="margin-top:10px">You can use an uppercase <code>A</code> to get the <code>a</code> with the creeper face.</p>
                  </div>
                ` },
                buttons: ["dialog.close"]
              }).show()
            },
            connectionInfo() {
              Blockbench.showMessageBox({
                title: "Failed to load textures and fonts",
                message: `Minecraft Title Generator was unable to load the textures and fonts. You will only be able to use the built-in texture and font.\n\nPlease make sure you are connected to the internet, and can access this <a href="${root}/fonts.json">fonts.json</a> file.\n\nIf you are unable to access the fonts.json file, it may be blocked by your computer or your internet service provider. If it is not your computer blocking it, you may be able to use a VPN to bypass the block. One good example is <a href="https://1.1.1.1/">Cloudflare WARP</a>, which is a free program that commonly resolves this issue.`
              })
            },
            tabChange(tab) {
              this.tab = tab
              document.querySelector("#new_minecraft_title_text .dialog_content").scrollTop = 0
              if (!tab) setTimeout(() => this.$el.querySelector("#minecraft-title-text-input").focus(), 0)
            }
          },
          computed: {
            linearGradient() {
              if (this.smoothGradient) return `linear-gradient(${[
                [this.gradientColour0, 0],
                this.gradientColour1Enabled ? [this.gradientColour1, 25] : null,
                this.gradientColour2Enabled ? [this.gradientColour2, 50] : null,
                this.gradientColour3Enabled ? [this.gradientColour3, 75] : null,
                [this.gradientColour4, 100]
              ].filter(e => e).map(e => `${e[0]} ${e[1]}%`)})`
              const states = [
                this.gradientColour1Enabled,
                this.gradientColour2Enabled,
                this.gradientColour3Enabled
              ]
              const stops = stopConfigs[states[0] << 2 | states[1] << 1 | states[2]]
              let prev = 0
              const colourStops = []
              for (let i = 0, j = 0; i < 5; i++) if (states[i-1] ?? true) {
                colourStops.push([this[`gradientColour${i}`], prev * 100])
                colourStops.push([this[`gradientColour${i}`], (stops[j] ?? 1) * 100])
                prev = stops[j] ?? 1
                j++
              }
              return `linear-gradient(${colourStops.map(e => `${e[0]} ${e[1]}%`)})`
            }
          },
          template: `
            <div id="${id}">
              <div class="dialog_close_button" style="right:30px;z-index:3" @click="reset()" title="Reset values back to their defaults">
                <i class="material-icons">replay</i>
              </div>
              <div class="dialog_close_button" style="right:60px;z-index:3" @click="presets" title="Load and save presets">
                <i class="material-icons">tune</i>
              </div>
              <div v-if="connection.failed" id="minecraft-title-connection-warning">
                <div @click="connectionInfo">
                  <svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,2L1,21H23M12,6L19.53,19H4.47M11,10V14H13V10M11,16V18H13V16" /></svg>
                  <div>Failed to load textures and fonts</div>
                  <div class="spacer"></div>
                  <div id="minecraft-title-connection-warning-underline">More Info</div>
                </div>
              </div>
              <div id="minecraft-title-tabs">
                <div @click="tabChange(0)" :class="{ selected: tab === 0 }">Text</div>
                <div @click="tabChange(1)" :class="{ selected: tab === 1 }">Texture</div>
                <div @click="tabChange(2)" :class="{ selected: tab === 2 }">Overlay</div>
                <div @click="tabChange(3)" :class="{ selected: tab === 3 }">Style</div>
                <div @click="tabChange(4)" :class="{ selected: tab === 4 }">Settings</div>
              </div>
              <div id="minecraft-title-preview-container" :class="{ visible: [1, 2, 3].includes(tab) }">
                <canvas @click="expandCanvas" id="minecraft-title-preview" class="checkerboard" width="2160" height="600"></canvas>
                <i @click="expandCanvas" class="material-icons icon">open_in_full</i>
                <i class="fa fa-file-import" title="Import texture into project" @click="importTexture"></i>
              </div>
              <div class="minecraft-title-contents" :class="{ visible: tab === 0 }">
                <h2>Minecraft Title Text</h2>
                <p>The text you want to add to the scene</p>
                <div class="text-input-row">
                  <input id="minecraft-title-text-input" class="dark_bordered" v-model="text" placeholder="Minecraft"/>
                  <i class="fa fa-circle-info" title="More info" @click="textInfo(font, baseFont)"></i>
                </div>
                <br>
                <div class="minecraft-title-header-row">
                  <h2>Font</h2>
                  <div class="github-link">
                    <a href="${links.github.link}">
                      <i class="icon fab fa-github"></i>
                      <div>Submit fonts</div>
                    </a>
                  </div>
                </div>
                <p>The font to use for the text</p>
                <ul class="form_inline_select">
                  <li @click="fontTab = 'fonts'" :class="{ selected: fontTab === 'fonts' }">Fonts</li>
                  <li @click="fonts[font].variants ? fontTab = 'variants' : null" :class="{ selected: fontTab === 'variants', disabled: !fonts[font].variants }">Variants</li>
                </ul>
                <div v-if="fontTab === 'fonts'" class="minecraft-title-list small">
                  <div class="minecraft-title-item" v-for="[id, data] of fontList" @click="font = id; baseFont = id; fontVariant = null; variant = null; updateFont()" :class="{ selected: baseFont === id }">
                    <img :src="data.thumbnail ?? connection.roots[connection.rootIndex] + '/fonts/' + id + '/thumbnails/flat.png'" loading="lazy" />
                    <div :style="{ maxWidth: data.variants ? '78%' : null }">{{ data.name }}</div>
                    <div class="minecraft-title-item-buttons">
                      <i v-if="data.author" class="minecraft-title-item-author material-icons" :data-author="'By ' + data.author">person</i>
                      <i class="fa fa-circle-info" title="More info" @click="textInfo(id)"></i>
                    </div>
                    <i v-if="data.variants" class="minecraft-title-item-has-variants material-icons" :title="'Has ' + (data.variants.length + 1) + ' variants'">filter_{{ data.variants.length > 9 ? '9_plus' : data.variants.length + 1 }}</i>
                  </div>
                </div>
                <div v-if="fonts[font].variants && fontTab === 'variants'" class="minecraft-title-list small">
                  <div class="minecraft-title-item" @click="font = baseFont; fontVariant = null; variant = null; updateFont()" :class="{ selected: !fontVariant }">
                    <img :src="connection.roots[connection.rootIndex] + '/fonts/' + baseFont + '/thumbnails/flat.png'" loading="lazy" />
                    <div>Default</div>
                    <div class="minecraft-title-item-buttons">
                      <i v-if="fonts[baseFont].author" class="minecraft-title-item-author material-icons" :data-author="'By ' + fonts[baseFont].author">person</i>
                      <i class="fa fa-circle-info" title="More info" @click="textInfo(baseFont)"></i>
                    </div>
                  </div>
                  <div class="minecraft-title-item" v-for="data of fonts[baseFont].variants" @click="font = data.id; fontVariant = data.id, variant = null; updateFont()" :class="{ selected: fontVariant === data.id }">
                    <img :src="connection.roots[connection.rootIndex] + '/fonts/' + data.id + '/thumbnails/flat.png'" loading="lazy" />
                    <div>{{ data.name }}</div>
                    <div class="minecraft-title-item-buttons">
                      <i v-if="data.author" class="minecraft-title-item-author material-icons" :data-author="'By ' + data.author">person</i>
                      <i class="fa fa-circle-info" title="More info" @click="textInfo(data.id, baseFont)"></i>
                    </div>
                  </div>
                </div>
                <br>
                <h2>Text Type / Angle</h2>
                <p>The type of text to add</p>
                <a href="javascript:void(0)" id="text-type-input" @click="event.stopPropagation()">
                  <select-input v-model="textType" :options="textTypes" />
                </a>
                <br>
                <h2>Text Row</h2>
                <p>The vertical row that the text will appear on</p>
                <div class="bar slider_input_combo">
                  <input type="range" class="tool disp_range" v-model.number="row" min="-10" max="10" step="1" />
                  <numeric-input class="tool disp_text" v-model.number="row" :min="-10" :max="10" :step="1" />
                </div>
              </div>
              <div class="minecraft-title-contents" :class="{ visible: tab === 1 }">
                <div class="minecraft-title-header-row">
                  <h2>Texture</h2>
                  <div class="github-link">
                    <a href="${links.github.link}">
                      <i class="icon fab fa-github"></i>
                      <div>Submit textures</div>
                    </a>
                  </div>
                </div>
                <p>The texture to apply to the text</p>
                <ul class="form_inline_select">
                  <li @click="textureSource = 'premade'; updatePreview()" :class="{ selected: textureSource === 'premade' }">Textures</li>
                  <li @click="textureSource = 'tileable'; updatePreview()" :class="{ selected: textureSource === 'tileable' }">Tileables</li>
                  <li @click="textureSource = 'gradient'; updatePreview()" :class="{ selected: textureSource === 'gradient' }">Gradient</li>
                  <li @click="lastTextureSource = textureSource; textureSource = 'file'; updatePreview()" :class="{ selected: textureSource === 'file' }">File</li>
                </ul>
                <div v-if="textureSource === 'premade'">
                  <div v-if="textures.filter(e => e[2] === font).length > 16" class="minecraft-texture-search">
                    <input type="text" placeholder="Searchâ€¦" class="dark_bordered" v-model="textureSearch">
                    <i class="material-icons">search</i>
                  </div>
                  <div class="minecraft-title-list">
                    <div class="minecraft-title-item" v-for="[id, data, type] of textures" v-if="font === type && (textures.filter(e => e[2] === font).length <= 16 || id.includes(textureSearch) || Object.keys(fonts[font].textures[id]?.variants ?? {}).some(e => e.includes(textureSearch)))" @click="texture = id; variant = null; updatePreview(); scrollToVariants()" :class="{ selected: texture === id }">
                      <img :src="data.thumbnail ?? connection.roots[connection.rootIndex] + '/fonts/' + font + '/thumbnails/' + id + '.png'" loading="lazy" />
                      <div :style="{ maxWidth: fonts[font].textures[id]?.variants ? '78%' : null }">{{ data.category ?? data.name }}</div>
                      <div class="minecraft-title-item-buttons">
                        <i v-if="data.author" class="minecraft-title-item-author material-icons" :data-author="'By ' + data.author">person</i>
                        <i class="material-icons" title="Save Texture" @click="saveTexture(font, 'textures', id)">save</i>
                      </div>
                      <i v-if="fonts[font].textures[id]?.variants" class="minecraft-title-item-has-variants material-icons" :title="'Has ' + (Object.keys(fonts[font].textures[id].variants).length + 1) + ' variants'">filter_{{ Object.keys(fonts[font].textures[id].variants).length > 8 ? '9_plus' : Object.keys(fonts[font].textures[id].variants).length + 1 }}</i>
                    </div>
                  </div>
                  <div v-if="fonts[font].textures[texture]?.variants">
                    <br>
                    <h2>Variants</h2>
                    <div class="minecraft-title-list" ref="textureVariants">
                      <div class="minecraft-title-item" @click="variant = null; updatePreview()" :class="{ selected: !variant }">
                        <img :src="connection.roots[connection.rootIndex] + '/fonts/' + font + '/thumbnails/' + texture + '.png'" loading="lazy" />
                        <div>{{ fonts[font].textures[texture].name }}</div>
                        <div class="minecraft-title-item-buttons">
                          <i v-if="fonts[font].textures[texture].author" class="minecraft-title-item-author material-icons" :data-author="'By ' + fonts[font].textures[texture].author">person</i>
                          <i class="material-icons" title="Save Texture" @click="saveTexture(font, 'textures', texture)">save</i>
                        </div>
                      </div>
                      <div class="minecraft-title-item" v-for="[id, data] of Object.entries(fonts[font].textures[texture].variants)" @click="variant = id; updatePreview()" :class="{ selected: variant === id }">
                        <img :src="connection.roots[connection.rootIndex] + '/fonts/' + font + '/thumbnails/' + id + '.png'" loading="lazy" />
                        <div>{{ data.name }}</div>
                        <div class="minecraft-title-item-buttons">
                          <i v-if="data.author ?? fonts[font].textures[texture].author" class="minecraft-title-item-author material-icons" :data-author="'By ' + (data.author ?? fonts[font].textures[texture].author)">person</i>
                          <i class="material-icons" title="Save Texture" @click="saveTexture(font, 'textures', texture, id)">save</i>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div v-if="textureSource === 'tileable'">
                  <div v-if="tileablesList.length > 16" class="minecraft-texture-search">
                    <input type="text" placeholder="Searchâ€¦" class="dark_bordered" v-model="textureSearch">
                    <i class="material-icons">search</i>
                  </div>
                  <div class="minecraft-title-list">
                    <div class="minecraft-title-item" v-for="[id, data] of tileablesList" v-if="tileablesList.length <= 16 || id.includes(textureSearch) || id === tileable || Object.keys(tileables[id]?.variants ?? {}).some(e => e.includes(textureSearch))" @click="tileable = id; tileableVariant = null; updatePreview(); scrollToVariants()" :class="{ selected: tileable === id }">
                      <div class="tileable-preview">
                        <div :style="{ backgroundImage: 'url(' + (data.texture ?? connection.roots[connection.rootIndex] + '/tileables/' + (data.path ? data.path + '/' : '') + id + '.png') + ')' }" />
                      </div>
                      <div :style="{ maxWidth: tileables[id]?.variants ? '78%' : null }">{{ data.category ?? data.name }}</div>
                      <div class="minecraft-title-item-buttons">
                        <i class="minecraft-title-item-author material-icons" :data-author="'By ' + data.author">person</i>
                        <i class="material-icons" title="Save Texture" @click="saveTexture(font, 'tileables', id)">save</i>
                      </div>
                      <i v-if="tileables[id]?.variants" class="minecraft-title-item-has-variants material-icons" :title="'Has ' + (Object.keys(tileables[id].variants).length + 1) + ' variants'">filter_{{ Object.keys(tileables[id].variants).length > 8 ? '9_plus' : Object.keys(tileables[id].variants).length + 1 }}</i>
                    </div>
                  </div>
                  <div v-if="tileables[tileable]?.variants">
                    <br>
                    <h2>Variants</h2>
                    <div class="minecraft-title-list" ref="textureVariants">
                      <div class="minecraft-title-item" @click="tileableVariant = null; updatePreview()" :class="{ selected: !tileableVariant }">
                        <div class="tileable-preview">
                          <div :style="{ backgroundImage: 'url(' + (tileables[tileable].texture ?? connection.roots[connection.rootIndex] + '/tileables/' + (tileables[tileable].path ? tileables[tileable].path + '/' : '') + tileable + '.png') + ')' }" />
                        </div>
                        <div>{{ tileables[tileable].name }}</div>
                        <div class="minecraft-title-item-buttons">
                          <i v-if="tileables[tileable].author" class="minecraft-title-item-author material-icons" :data-author="'By ' + tileables[tileable].author">person</i>
                          <i class="material-icons" title="Save Texture" @click="saveTexture(font, 'tileables', tileable)">save</i>
                        </div>
                      </div>
                      <div class="minecraft-title-item" v-for="[id, data] of Object.entries(tileables[tileable].variants)" @click="tileableVariant = id; updatePreview()" :class="{ selected: tileableVariant === id }">
                        <div class="tileable-preview">
                          <div :style="{ backgroundImage: 'url(' + (data.texture ?? connection.roots[connection.rootIndex] + '/tileables/' + (tileables[tileable].path ? tileables[tileable].path + '/' : '') + id + '.png') + ')' }" />
                        </div>
                        <div>{{ data.name }}</div>
                        <div class="minecraft-title-item-buttons">
                          <i class="minecraft-title-item-author material-icons" :data-author="'By ' + (data.author ?? tileables[tileable].author)">person</i>
                          <i class="material-icons" title="Save Texture" @click="saveTexture(font, 'tileables', tileable, id)">save</i>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div :class="{ hidden: textureSource !== 'gradient' }" id="custom-gradient">
                  <div id="custom-gradient-customiser">
                    <div id="gradient-preview" :style="{ background: linearGradient }"></div>
                    <div id="gradient-colours">
                      <div>
                        <input ref="gradientColour0" />
                      </div>
                      <div>
                        <input type="checkbox" :checked="gradientColour1Enabled" v-model="gradientColour1Enabled" @input="updatePreview">
                        <input ref="gradientColour1" :class="{ disabled: !gradientColour1Enabled }" />
                      </div>
                      <div>
                        <input type="checkbox" :checked="gradientColour2Enabled" v-model="gradientColour2Enabled" @input="updatePreview">
                        <input ref="gradientColour2" :class="{ disabled: !gradientColour2Enabled }" />
                      </div>
                      <div>
                        <input type="checkbox" :checked="gradientColour3Enabled" v-model="gradientColour3Enabled" @input="updatePreview">
                        <input ref="gradientColour3" :class="{ disabled: !gradientColour3Enabled }" />
                      </div>
                      <div>
                        <input ref="gradientColour4" />
                      </div>
                    </div>
                  </div>
                  <label class="checkbox-row" style="margin-top: 10px">
                    <input type="checkbox" :checked="smoothGradient" v-model="smoothGradient" @input="updatePreview">
                    <div>Smooth gradient</div>
                  </label>
                </div>
                <div :class="{ hidden: textureSource !== 'file' }" id="minecraft-title-custom-texture" class="minecraft-title-file">
                  <canvas class="checkerboard" width="500" height="160"  @click="selectCustomTexture" />
                  <i v-if="customTexture" class="material-icons" title="Delete custom texture" @click="deleteCustomTexture">delete</i>
                  <div class="minecraft-title-button-row">
                    <button @click="selectCustomTexture">Select file</button>
                    <button @click="importTextureAsFile" title="Import the current selected texture as a custom texture, with its overlay and styles applied">Import current texture as file</button>
                  </div>
                  <div class="radio-row">
                    <div>Texture Type:</div>
                    <label for="custom-texture-type-texture">
                      <input type="radio" id="custom-texture-type-texture" value="texture" v-model="customTextureType" @input="updatePreview" />
                      <div>Texture</div>
                    </label>
                    <label for="custom-texture-type-tileable">
                      <input type="radio" id="custom-texture-type-tileable" value="tileable" v-model="customTextureType" @input="updatePreview" />
                      <div>Tileable</div>
                    </label>
                  </div>
                </div>
              </div>
              <div class="minecraft-title-contents" :class="{ visible: tab === 2 }">
                <div class="minecraft-title-header-row">
                  <h2>Overlay Texture</h2>
                  <div class="github-link">
                    <a href="${links.github.link}">
                      <i class="icon fab fa-github"></i>
                      <div>Submit overlays</div>
                    </a>
                  </div>
                </div>
                <p>A texture to overlay onto the text</p>
                <ul class="form_inline_select">
                  <li @click="overlaySource = 'premade'; updatePreview()" :class="{ selected: overlaySource === 'premade' }">Textures</li>
                  <li @click="overlaySource = 'file'; updatePreview()" :class="{ selected: overlaySource === 'file' }">File</li>
                </ul>
                <div v-if="overlaySource === 'premade'" class="minecraft-title-list small">
                  <div class="minecraft-title-item" v-for="[id, data, type] of overlays" v-if="font === type" @click="overlay = id; updatePreview()" :class="{ selected: overlay === id }">
                    <img :src="data.thumbnail ?? connection.roots[connection.rootIndex] + '/fonts/' + font + '/thumbnails/' + id + '.png'" loading="lazy" />
                    <div>{{ data.name }}</div>
                    <div class="minecraft-title-item-buttons">
                      <i v-if="data.author" class="minecraft-title-item-author material-icons" :data-author="'By ' + data.author">person</i>
                      <i class="material-icons" title="Save Texture" @click="saveTexture(font, 'overlays', id)">save</i>
                    </div>
                  </div>
                </div>
                <div :class="{ hidden: overlaySource !== 'file' }" id="minecraft-title-custom-overlay" class="minecraft-title-file" @click="selectCustomOverlay">
                  <canvas class="checkerboard" width="500" height="160" />
                  <button>Select file</button>
                </div>
                <br>
                <p>The blend method to use when applying the overlay</p>
                <select-input v-model="overlayBlend" :options="blends" @input="updatePreview" />
                <br>
                <h2>Overlay Colour</h2>
                <p>A colour to apply to the overlay texture</p>
                <input ref="overlayColour" />
                <p>The blend method to use when applying the colour</p>
                <select-input v-model="overlayColourBlend" :options="blends" @input="updatePreview" />
                <br>
                <h2>Overlay Opacity</h2>
                <p>The opacity to apply the overlay at</p>
                <div class="bar slider_input_combo">
                  <input type="range" class="tool disp_range" v-model.number="overlayOpacity" min="0" max="100" step="1" @input="updatePreview" />
                  <numeric-input class="tool disp_text" v-model.number="overlayOpacity" :min="0" :max="100" :step="1" @input="updatePreview" />
                </div>
              </div>
              <div class="minecraft-title-contents" :class="{ visible: tab === 3 }">
                <div v-if="textureSource === 'tileable' || textureSource === 'file' && customTexture && customTextureType === 'tileable'">
                  <h2>Configuration</h2>
                  <p>Configure the tileable texture</p>
                  <div class="bar slider_input_combo">
                    <div class="slider-label" style="width: 60px;">Scale:</div>
                    <input type="range" class="tool disp_range" v-model.number="tileableScale" min="1" max="8" step="1" @input="updatePreview" />
                    <numeric-input class="tool disp_text" v-model.number="tileableScale" :min="1" :max="8" :step="1" @input="updatePreview" />
                  </div>
                  <div class="bar slider_input_combo">
                    <div class="slider-label" style="width: 60px;">X Offset:</div>
                    <input type="range" class="tool disp_range" v-model.number="tileableXOffset" min="0" :max="tileableWidth" step="1" @input="updatePreview" />
                    <numeric-input class="tool disp_text" v-model.number="tileableXOffset" :min="0" :max="tileableWidth" :step="1" @input="updatePreview" />
                  </div>
                  <div class="bar slider_input_combo">
                    <div class="slider-label" style="width: 60px;">Y Offset:</div>
                    <input type="range" class="tool disp_range" v-model.number="tileableYOffset" min="0" :max="tileableHeight" step="1" @input="updatePreview" />
                    <numeric-input class="tool disp_text" v-model.number="tileableYOffset" :min="0" :max="tileableHeight" :step="1" @input="updatePreview" />
                  </div>
                  <label class="checkbox-row">
                    <input type="checkbox" :checked="tileableRandomRotations" v-model="tileableRandomRotations" @input="updatePreview">
                    <div>Random Rotations</div>
                  </label>
                  <label class="checkbox-row">
                    <input type="checkbox" :checked="tileableRandomMirroring" v-model="tileableRandomMirroring" @input="updatePreview">
                    <div>Random Mirroring</div>
                  </label>
                  <div class="bar slider_input_combo">
                    <div class="slider-label">Texture Resolution:</div>
                    <input type="range" class="tool disp_range" v-model.number="tileableTextureResolution" min="1000" :max="4000" step="1000" @input="updatePreview" />
                    <numeric-input class="tool disp_text" v-model.number="tileableTextureResolution" :min="1000" :max="4000" :step="1000" @input="updatePreview" />
                  </div>
                  <br>
                </div>
                <h2>Filters</h2>
                <p>Apply some filters to the chosen texture</p>
                <div class="bar slider_input_combo">
                  <div class="slider-label" style="width: 70px">Hue</div>
                  <input type="range" class="tool disp_range" v-model.number="hue" min="0" max="359" step="1" @input="updatePreview" />
                  <numeric-input class="tool disp_text" v-model.number="hue" :min="0" :max="359" :step="1" @input="updatePreview" />
                </div>
                <div class="bar slider_input_combo">
                  <div class="slider-label" style="width: 70px">Saturation</div>
                  <input type="range" class="tool disp_range" v-model.number="saturation" min="0" max="200" step="1" @input="updatePreview" />
                  <numeric-input class="tool disp_text" v-model.number="saturation" :min="0" :max="200" :step="1" @input="updatePreview" />
                </div>
                <div class="bar slider_input_combo">
                  <div class="slider-label" style="width: 70px">Brightness</div>
                  <input type="range" class="tool disp_range" v-model.number="brightness" min="0" max="200" step="1" @input="updatePreview" />
                  <numeric-input class="tool disp_text" v-model.number="brightness" :min="0" :max="200" :step="1" @input="updatePreview" />
                </div>
                <div class="bar slider_input_combo">
                  <div class="slider-label" style="width: 70px">Contrast</div>
                  <input type="range" class="tool disp_range" v-model.number="contrast" min="0" max="200" step="1" @input="updatePreview" />
                  <numeric-input class="tool disp_text" v-model.number="contrast" :min="0" :max="200" :step="1" @input="updatePreview" />
                </div>
                <br>
                <h2>Colour</h2>
                <p>A colour to apply to the chosen texture</p>
                <input ref="colour" />
                <p>The blend method to use when applying the colour</p>
                <select-input v-model="blend" :options="blends" @input="updatePreview" />
                <p style="margin:15px 0 -5px">The opacity to apply the colour at</p>
                <div class="bar slider_input_combo">
                  <input type="range" class="tool disp_range" v-model.number="colourOpacity" min="0" max="100" step="1" @input="updatePreview" />
                  <numeric-input class="tool disp_text" v-model.number="colourOpacity" :min="0" :max="100" :step="1" @input="updatePreview" />
                </div>
                <br>
                <h2>Border</h2>
                <label class="checkbox-row">
                  <input type="checkbox" :checked="customBorder" v-model="customBorder" @input="updatePreview">
                  <div>Use a custom colour for the text border</div>
                </label>
                <input ref="customBorderColour" :class="{ hidden: !customBorder }" />
                <label class="checkbox-row">
                  <input type="checkbox" :checked="fadeToBorder" v-model="fadeToBorder" @input="updatePreview">
                  <div>Fade the top and bottom of the text into the border colour</div>
                </label>
                <br>
                <h2>Edges</h2>
                <label class="checkbox-row">
                  <input type="checkbox" :checked="customEdge" v-model="customEdge" @input="updatePreview">
                  <div>Use a custom colour for the top and bottom faces</div>
                </label>
                <input ref="customEdgeColour" :class="{ hidden: !customEdge }" />
                <div :class="{ hidden: !(!customEdge && (textureSource === 'tileable' || textureSource === 'gradient' || textureSource === 'file' && customTexture && customTextureType === 'tileable')) }">
                  <div class="bar slider_input_combo">
                    <div class="slider-label">Edge brightness:</div>
                    <input type="range" class="tool disp_range" v-model.number="edgeBrightness" min="0" max="100" step="1" @input="updatePreview" />
                    <numeric-input class="tool disp_text" v-model.number="edgeBrightness" :min="0" :max="100" :step="1" @input="updatePreview" />
                  </div>
                </div>
                <label v-if="!fonts[font].forcedTerminators" class="checkbox-row">
                  <input type="checkbox" :checked="terminators" v-model="terminators" @input="buildPreview">
                  <div>Enable line terminators</div>
                </label>
                <p v-if="!fonts[font].forcedTerminators">Line terminators are special characters that appear at the start and end of the text</p>
              </div>
              <div class="minecraft-title-contents" :class="{ visible: tab === 4 }">
                <h2>Character Spacing</h2>
                <p>Add a space between each character</p>
                <div class="bar slider_input_combo">
                  <input type="range" class="tool disp_range" v-model.number="characterSpacing" min="0" max="20" step="1" />
                  <numeric-input class="tool disp_text" v-model.number="characterSpacing" :min="0" :max="20" :step="1" />
                </div>
                <br>
                <h2>Row Spacing</h2>
                <p>Change the spacing between the vertical rows of text</p>
                <div class="bar slider_input_combo">
                  <input type="range" class="tool disp_range" v-model.number="rowSpacing" min="-4" max="20" step="1" />
                  <numeric-input class="tool disp_text" v-model.number="rowSpacing" :min="-4" :max="20" :step="1" />
                </div>
                <br>
                <h2>Text Scale</h2>
                <p>The scale to render the text<br>For advanced scaling, use <strong>Transform > Scale</strong> after adding the text</p>
                <div class="bar slider_input_combo">
                  <div class="slider-label">X</div>
                  <input type="range" class="tool disp_range" v-model.number="scaleX" min="0.05" max="4" step="0.05" style="--color-thumb:var(--color-axis-x)" />
                  <numeric-input class="tool disp_text" v-model.number="scaleX" :min="0.05" :max="4" :step="0.05" />
                </div>
                <div class="bar slider_input_combo">
                  <div class="slider-label">Y</div>
                  <input type="range" class="tool disp_range" v-model.number="scaleY" min="0.05" max="4" step="0.05" style="--color-thumb:var(--color-axis-y)" />
                  <numeric-input class="tool disp_text" v-model.number="scaleY" :min="0.05" :max="4" :step="0.05" />
                </div>
                <div class="bar slider_input_combo">
                  <div class="slider-label">Z</div>
                  <input type="range" class="tool disp_range" v-model.number="scaleZ" min="0.05" max="4" step="0.05" style="--color-thumb:var(--color-axis-z)" />
                  <numeric-input class="tool disp_text" v-model.number="scaleZ" :min="0.05" :max="4" :step="0.05" />
                </div>
              </div>
              <div id="minecraft-title-buttons">
                <button v-if="tab > 0" @click="tabChange(tab - 1)">Back</button>
                <div class="spacer"></div>
                <button v-if="tab < 4" @click="tabChange(tab + 1)">Next</button>
                <button @click="finish">Finish</button>
              </div>
            </div>
          `
        },
        onOpen() {
          setTimeout(async () => {
            this.content_vue.tab = 0
            this.content_vue.$el.querySelector("#minecraft-title-text-input").focus()
            if (!await MinecraftEULA.promptUser(id)) return dialog.close()
          }, 0)
        },
        onConfirm() {
          const text = this.content_vue.text.replace(/A/g, "ðŸ˜³").replace(/(\s|^)'/g, "$1ðŸ˜©").replace(/(\s|^)"/g, "$1ðŸ˜©ðŸ˜©").replace(/"/g, "''").toLowerCase().trim()
          if (!text) {
            this.content_vue.tab = 0
            Blockbench.showQuickMessage("Please provide some text")
            return false
          }
          dialog.close()
          addText(text, getArgs(this.content_vue))
        },
        async onBuild() {
          await getFontTextures("minecraft-ten", true)
          stats.push(...await fetch("https://api.wynem.com/blockbench/minecrafttitlegenerator/stats", { headers: { source: "blockbench" } }).then(e => e.json()).catch(() => []))
          const ten = stats.find(e => e.id === "minecraft-ten")
          if (ten) ten.count = Infinity
          else stats.push({
            id: "minecraft-ten",
            count: Infinity
          })
          fontData.push(...await fetchData("fonts.json", () => []))
          for (let [i, font] of fontData.entries()) {
            if (fonts[font.id]) {
              fonts[font.id] = Object.assign(fonts[font.id], font)
              font = fonts[font.id]
              fontData[i] = font
            } else {
              font.name ??= titleCase(font.id)
              font.characters = `fonts/${font.id}/characters.json`
              font.textures = `fonts/${font.id}/textures.json`
              fonts[font.id] = font
            }
            font.parsed = true
            if (font.variants) for (const [j, v] of font.variants.entries()) {
              const variant = Object.assign({}, font, v)
              delete variant.thumbnail
              variant.name ??= titleCase(variant.id)
              variant.characters = `fonts/${variant.id}/characters.json`
              variant.textures = `fonts/${variant.id}/textures.json`
              delete variant.overlays
              fonts[variant.id] = variant
              font.variants[j] = variant
              variant.parsed = true
            }
          }
          for (const font of Object.entries(fonts).filter(e => !e[1].parsed)) {
            font[1].id = font[0]
            fontData.push(font[1])
          }
          tileables = Object.assign(tileables, await fetchData("tileables.json"))
          for (const [id, tileable] of Object.entries(tileables)) {
            tileable.name ??= titleCase(id)
            tileable.author ??= "Mojang"
            tileable.path ??= "minecraft"
            if (tileable.variants) for (const [id, variant] of Object.entries(tileable.variants)) {
              variant.name ??= titleCase(id)
              variant.path ??= tileable.path
            }
          }
          this.content_vue.fontList = fontData.map(e => [e.id, e])
          this.content_vue.textures = Object.entries(fonts["minecraft-ten"].textures).map(e => e.concat(["minecraft-ten"]))
          this.content_vue.tileablesList = Object.entries(tileables)
          this.content_vue.overlays = Object.entries(fonts["minecraft-ten"].overlays).map(e => e.concat(["minecraft-ten"]))
          if (Object.keys(fonts["minecraft-ten"].textures)[1]) this.content_vue.texture = Object.keys(fonts["minecraft-ten"].textures)[1]
          this.content_vue.fontList.sort((a, b) => {
            const statsA = stats.find(e => e.id === a[0])?.count ?? 0
            const statsB = stats.find(e => e.id === b[0])?.count ?? 0
            return statsB - statsA
          })
          this.content_vue.textures.sort((a, b) => {
            const statsA = stats.find(e => e.id === `${a[2]}.${a[0]}`)?.count ?? 0
            const statsB = stats.find(e => e.id === `${a[2]}.${b[0]}`)?.count ?? 0
            return statsB - statsA
          })
          this.content_vue.tileablesList.sort((a, b) => {
            const statsA = stats.find(e => e.id === `tileable.${a[0]}`)?.count ?? 0
            const statsB = stats.find(e => e.id === `tileable.${b[0]}`)?.count ?? 0
            return statsB - statsA
          })
          this.content_vue.overlays.sort((a, b) => {
            const statsA = stats.find(e => e.id === `${a[2]}.${a[0]}`)?.count ?? 0
            const statsB = stats.find(e => e.id === `${a[2]}.${b[0]}`)?.count ?? 0
            return statsB - statsA
          })
          this.content_vue.$forceUpdate()

          this.content_vue.canvas = dialog.content_vue.$el.querySelector("#minecraft-title-preview")
          this.content_vue.customTextureCanvas = dialog.content_vue.$el.querySelector("#minecraft-title-custom-texture > canvas")
          this.content_vue.customOverlayCanvas = dialog.content_vue.$el.querySelector("#minecraft-title-custom-overlay > canvas")
          this.content_vue.customTextureCanvas.getContext("2d").globalCompositeOperation = "copy"
          this.content_vue.customOverlayCanvas.getContext("2d").globalCompositeOperation = "copy"

          this.content_vue.camera = new THREE.PerspectiveCamera(18, this.content_vue.canvas.width / this.content_vue.canvas.height, 1, 1000)
          this.content_vue.camera.position.x = 0
          this.content_vue.camera.position.y = -170
          this.content_vue.camera.position.z = -320
          this.content_vue.camera.lookAt(new THREE.Vector3(0, 0, 0))

          this.content_vue.scene = new THREE.Scene()

          this.content_vue.buildPreview()
        }
      })
      debugDialog = new Dialog({
        id: `debug_${id}`,
        title: "Load Debug Minecraft Title Text",
        component: {
          data: {
            connection,
            font: Object.keys(fonts)[0],
            fonts,
            texture: Object.keys(fonts["minecraft-ten"].textures)[1] ?? Object.keys(fonts["minecraft-ten"].textures)[0],
            variant: null,
          },
          methods: {
            async selectFont(id) {
              await getFontTextures(id)
              this.font = id
              this.texture = Object.keys(fonts[id].textures)[1] ?? Object.keys(fonts[id].textures)[0]
              this.variant = null
            }
          },
          template: `
            <div>
              <h2>Font</h2>
              <div class="minecraft-title-list small">
                <div class="minecraft-title-item" v-for="[id, data] of Object.entries(fonts)" @click="selectFont(id)" :class="{ selected: font === id }">
                  <img :src="data.thumbnail ?? connection.roots[connection.rootIndex] + '/fonts/' + id + '/thumbnails/flat.png'" loading="lazy" />
                  <div>{{ data.name }}</div>
                </div>
              </div>
              <br>
              <h2>Texture</h2>
              <div class="minecraft-title-list">
                <div class="minecraft-title-item" @click="texture = 'all'; variant = null" :class="{ selected: texture === 'all' }">
                  <div>All</div>
                </div>
                <div class="minecraft-title-item" v-for="[id, data] of Object.entries(fonts[font].textures)" v-if="fonts[font].textures[id]" @click="texture = id; variant = null" :class="{ selected: texture === id }">
                  <img :src="data.thumbnail ?? connection.roots[connection.rootIndex] + '/fonts/' + font + '/thumbnails/' + id + '.png'" loading="lazy" />
                  <div>{{ data.category ?? data.name }}</div>
                  <i v-if="fonts[font].textures[id]?.variants" class="minecraft-title-item-has-variants material-icons" :title="'Has ' + (Object.keys(fonts[font].textures[id].variants).length + 1) + ' variants'">filter_{{ Object.keys(fonts[font].textures[id].variants).length > 8 ? '9_plus' : Object.keys(fonts[font].textures[id].variants).length + 1 }}</i>
                </div>
              </div>
              <div v-if="fonts[font].textures[texture]?.variants">
                <br>
                <h2>Texture Variants</h2>
                <div class="minecraft-title-list">
                  <div class="minecraft-title-item" @click="variant = null" :class="{ selected: !variant }">
                    <img :src="connection.roots[connection.rootIndex] + '/fonts/' + font + '/thumbnails/' + texture + '.png'" loading="lazy" />
                    <div>{{ fonts[font].textures[texture].name }}</div>
                  </div>
                  <div class="minecraft-title-item" v-for="[id, data] of Object.entries(fonts[font].textures[texture].variants)" @click="variant = id" :class="{ selected: variant === id }">
                    <img :src="connection.roots[connection.rootIndex] + '/fonts/' + font + '/thumbnails/' + id + '.png'" loading="lazy" />
                    <div>{{ data.name }}</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          `
        },
        async onConfirm() {
          await getFontCharacters(this.content_vue.font)
          const str = Object.keys(fonts[this.content_vue.font].characters).sort().join("").replace(/ðŸ˜©|ðŸ˜³/g, "").replace("a", "ðŸ˜³a").replace("'", "ðŸ˜©'")
          const scale = [1, 1, 1]
          if (this.content_vue.texture === "all") {
            const textures = []
            for (const [id, data] of Object.entries(fonts[this.content_vue.font].textures)) {
              textures.push([id])
              if (data.variants) textures.push(...Object.keys(data.variants).map(e => [id, e]))
            }
            for (const [i, texture] of textures.entries()) {
              await addText(str, {
                debug: true,
                font: this.content_vue.font,
                texture: texture[0],
                variant: texture[1],
                row: textures.length - i - 1,
                characterSpacing: 8,
                rowSpacing: 8,
                blend: "multiply",
                colour: "#fff",
                scale,
                customBorder: false,
                spacerWidth: 31,
                name: texture[1] ?? texture[0],
                ignoreStats: true,
                ignoreTextureCheck: true
              })
            }
          } else {
            const parts = []
            let part = ""
            let x = 0
            for (const char of str) {
              part += char
              x++
              if (x >= 11) {
                x = 0
                parts.push(part)
                part = ""
              }
            }
            if (part) parts.push(part)
            for (const [i, part] of parts.entries()) {
              await addText(part, {
                debug: true,
                font: this.content_vue.font,
                texture: this.content_vue.texture,
                variant: this.content_vue.variant,
                row: parts.length - i - 1,
                characterSpacing: 8,
                rowSpacing: 8,
                blend: "multiply",
                colour: "#fff",
                scale,
                customBorder: false,
                spacerWidth: 31,
                name: this.content_vue.variant ?? this.content_vue.texture,
                ignoreStats: true
              })
            }
          }
        }
      })
      debug = new Action("load_debug_minecraft_title_text", {
        name: "Load Debug Minecraft Title Text",
        icon,
        condition: () => Project.format === format,
        click: () => debugDialog.show()
      })
      MenuBar.addAction(debug, "help.developer.1")
      Blockbench.on("update_selection", selectHandler)
    },
    onunload() {
      Blockbench.removeListener("update_selection", selectHandler)
      MenuBar.removeAction("help.about_plugins.about_minecraft_title_generator")
      format.delete()
      action.delete()
      mode.delete()
      panel.delete()
      styles.delete()
      preview.delete()
      debug.delete()
      dialog.close()
      debugDialog.close()
    }
  })

  async function fetchData(path, fallback) {
    try {
      const r = await fetch(`${root}/${path}`)
      if (r.status !== 200) throw new Error
      if (r.headers.get("Content-Type")?.startsWith("text/plain") || r.headers.get("Content-Type")?.startsWith("application/json")) return r.json()
      return r
    } catch {
      for (let x = connection.rootIndex + 1; x < connection.roots.length; x++) {
        connection.rootIndex = x
        try {
          const r = await fetch(`${connection.roots[x]}/${path}`)
          if (r.status !== 200) throw new Error
          root = connection.roots[x]
          if (r.headers.get("Content-Type")?.startsWith("text/plain") || r.headers.get("Content-Type")?.startsWith("application/json")) return r.json()
          return r
        } catch {}
      }
      connection.failed = true
      return fallback ? fallback() : {}
    }
  }

  function sendStats(args, font) {
    let chosenTexture, chosenTileable
    if (!args.gradientColour0 && !args.customTexture) {
      if (args.tileable) chosenTileable = args.tileable
      else chosenTexture = args.texture
    }
    const chosenOverlay = args.customOverlay || args.overlay === "none" ? undefined : args.overlay
    if (font || chosenTexture || chosenTileable || chosenOverlay) fetch("https://api.wynem.com/blockbench/minecrafttitlegenerator/stats", {
      method: "POST",
      headers: {
        source: "blockbench",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        font: args.font,
        ignoreFont: !font,
        texture: chosenTexture,
        tileable: chosenTileable,
        overlay: chosenOverlay
      })
    }).catch(() => {})
  }

  async function getTexture(object, texture, variant, direct) {
    if (!direct && ((variant && object[texture].variants[variant]?.texture.startsWith("data:image/png;base64,")) || (!variant && object[texture].texture.startsWith("data:image/png;base64,")))) return variant ? object[texture].variants[variant].texture : object[texture].texture
    const data = await new Promise(async fulfil => {
      const reader = new FileReader()
      reader.onload = e => fulfil(e.target.result)
      reader.readAsDataURL(new Blob([await fetchData(direct ?? (variant ? object[texture].variants[variant].texture : object[texture].texture)).then(e => e.arrayBuffer())], { type: "image/png" }))
    }).catch(() => {})
    if (!direct) {
      if (variant) object[texture].variants[variant].texture = data
      else object[texture].texture = data
    }
    return data
  }

  async function addText(text, args) {
    args.text = text
    const elements = []
    const textures = []
    Undo.initEdit({
      outliner: true,
      elements,
      textures
    })
    let texture = await makeTexture(args)
    let match
    if (!args.ignoreTextureCheck) for (const image of Texture.all) {
      if (image.img.src === texture.img.src) {
        match = true
        texture = image
        break
      }
    }
    if (!match) {
      texture.add()
      textures.push(texture)
    }
    await getFontCharacters(args.font)
    if (!args.debug && args.characterSpacing && fonts[args.font].characters["â€‹"]) {
      text = text.split("").join("â€‹")
      args.spacerWidth = args.characterSpacing - 1
      args.characterSpacing = 0
    }
    if (!args.debug && (args.terminators || fonts[args.font].forcedTerminators) && fonts[args.font].terminatorSpace) {
      text = `â”« ${text} â”£`
    } else if (!args.debug && (args.terminators || fonts[args.font].forcedTerminators)) {
      text = `â”«${text}â”£`
    }
    let words
    if (fonts[args.font].characters[" "]) words = [text]
    else words = text.split(" ")
    let group
    let offset = 0
    if (words.length === 1) {
      [group] = makeWord(text, offset, "root", {
        font: args.font,
        texture: texture.uuid,
        row: args.row,
        type: args.type,
        characterSpacing: args.characterSpacing,
        spacerWidth: args.spacerWidth,
        rowSpacing: args.rowSpacing,
        scale: args.scale,
        name: args.name,
        elements
      })
    } else {
      group = new Group(args.name ?? makeName(text)).init()
      for (const part of words) {
        const [word, newOffset] = makeWord(part, offset, group, {
          font: args.font,
          texture: texture.uuid,
          row: args.row,
          type: args.type,
          characterSpacing: args.characterSpacing,
          spacerWidth: args.spacerWidth,
          rowSpacing: args.rowSpacing,
          scale: args.scale,
          elements
        })
        offset = newOffset + (8 + args.characterSpacing) * args.scale[0]
      }
    }
    group.addTo().select()
    let min = Infinity
    let max = -Infinity
    for (const cube of Cube.selected) {
      min = Math.min(min, cube.from[0], cube.to[0])
      max = Math.max(max, cube.from[0], cube.to[0])
    }
    let width = (max - min) / 2
    if (fonts[args.font].autoBorder) width -= 2 * (args.scale[0] + args.scale[1]) / 2 * (args.type === "bottom" ? 0.75 : args.type === "small" ? 0.35 : 1)
    for (const cube of Cube.selected) {
      cube.from[0] += width
      cube.to[0] += width
    }
    if (args.type === "bottom") {
      group.rotation[0] = -90
    }
    Canvas.updateView({
      elements: Cube.selected,
      groups: [Group.selected]
    })
    Undo.finishEdit("Add Minecraft title text")
    updateSelection()
    if (!args.ignoreStats) sendStats(args, true)
  }

  async function makeTexture(args) {
    const img = await loadImage(args.customTexture && args.customTextureType === "texture" ? args.customTexture : await getTexture(fonts[args.font].textures, args.texture, args.variant))
    const res = args.tileable || args.customTexture && args.customTextureType === "tileable" ? args.tileableTextureResolution / 1000 : 1
    let { canvas, ctx } = new CanvasFrame(img.width * res, img.height * res)
    ctx.imageSmoothingEnabled = false
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
    let m = canvas.width / 1000
    if (args.gradientColour0) {
      if (args.smoothGradient) {
        const colours = [
          [args.gradientColour0, 0],
          args.gradientColour1 ? [args.gradientColour1, 0.25] : null,
          args.gradientColour2 ? [args.gradientColour2, 0.50] : null,
          args.gradientColour3 ? [args.gradientColour3, 0.75] : null,
          [args.gradientColour4, 1]
        ].filter(e => e)
        const height = fonts[args.font].ends[fonts[args.font].ends.length - 1][3]
        if (canvas.width < 4000) {
          const newCanvas = new CanvasFrame(4000, 1280)
          newCanvas.ctx.imageSmoothingEnabled = false
          newCanvas.ctx.drawImage(canvas, 0, 0, 4000, 1280)
          canvas = newCanvas.canvas
          ctx = newCanvas.ctx
          m = canvas.width / 1000
        }
        ctx.globalCompositeOperation = "source-atop"
        const gradient = ctx.createLinearGradient(0, 0, 0, height * m)
        for (let i = 0; i < fonts[args.font].faces.length; i++) {
          const face = fonts[args.font].faces[i]
          const end = fonts[args.font].ends[i]
          gradient.addColorStop(end[0] / height, args.gradientColour0)
          if (face.length === 2) {
            gradient.addColorStop(face[0] / height, args.gradientColour0)
            for (const stop of colours) {
              gradient.addColorStop(Math.lerp(face[0], face[1], stop[1]) / height, stop[0])
            }
            gradient.addColorStop(face[1] / height, args.gradientColour4)
          } else {
            gradient.addColorStop(face[0] / height, args.gradientColour0)
            gradient.addColorStop(face[1] / height, args.gradientColour0)
            for (const stop of colours) {
              gradient.addColorStop(Math.lerp(face[1], face[2], stop[1]) / height, stop[0])
            }
            gradient.addColorStop(face[2] / height, args.gradientColour4)
            gradient.addColorStop(face[3] / height, args.gradientColour4)
          }
          gradient.addColorStop(end[3] / height, args.gradientColour4)
        }
        ctx.fillStyle = gradient
        ctx.fillRect(0, 0, canvas.width * m, height * m)
      } else {
        const charHeight = fonts[args.font].faces[0][3] ? fonts[args.font].faces[0][2] - fonts[args.font].faces[0][1] : fonts[args.font].faces[0][1] - fonts[args.font].faces[0][0]
        const states = [
          !!args.gradientColour1,
          !!args.gradientColour2,
          !!args.gradientColour3
        ]
        const stops = stopConfigs[states[0] << 2 | states[1] << 1 | states[2]]
        for (let i = 0; i < fonts[args.font].faces.length; i++) {
          const face = fonts[args.font].faces[i]
          const end = fonts[args.font].ends[i]
          const offset = face[3] ? face[1] : face[0] 
          let prev = 0
          for (let i = 0, j = 0; i < 5; i++) if (states[i-1] ?? true) {
            const end = Math.floor((stops[j] ?? 1) * charHeight)
            ctx.fillStyle = args[`gradientColour${i}`]
            ctx.fillRect(0, offset + prev, canvas.width, end - prev)
            prev = end
            j++
          }
          ctx.fillStyle = args.gradientColour0
          ctx.fillRect(0, end[0], canvas.width, (face[3] ? face[1] : end[1]) - end[0])
          ctx.fillStyle = args.gradientColour4
          ctx.fillRect(0, (face[2] ?? end[2]), canvas.width, end[3] - (face[2] ?? end[2]))
        }
      }
      ctx.fillStyle = `rgba(0, 0, 0, ${(100 - args.edgeBrightness) / 100})`
      for (const end of fonts[args.font].ends) {
        ctx.fillRect(0, end[0] * m, canvas.width, end[1] * m - end[0] * m)
        ctx.fillRect(0, end[2] * m, canvas.width, end[3] * m - end[2] * m)
      }
      if (fonts[args.font].overlay) {
        await loadOverlay(args.font)
        ctx.drawImage(fonts[args.font].overlay, 0, 0, canvas.width, canvas.height)
      }
    } else if (args.tileable || args.customTexture && args.customTextureType === "tileable") {
      let base
      if (args.customTexture) base = await loadImage(args.customTexture)
      else base = await loadImage(await getTileable(args.tileable, args.tileableVariant))
      const { canvas: texture, ctx: tctx } = new CanvasFrame(base.width, base.height)
      tctx.drawImage(base, -args.tileableXOffset, -args.tileableYOffset)
      if (args.tileableXOffset) tctx.drawImage(base, base.width - args.tileableXOffset, -args.tileableYOffset)
      if (args.tileableYOffset) tctx.drawImage(base, -args.tileableXOffset, base.height - args.tileableYOffset)
      if (args.tileableXOffset && args.tileableYOffset) tctx.drawImage(base, base.width - args.tileableXOffset, base.height - args.tileableYOffset)
      const width = Math.max(1, Math.round(texture.width * args.tileableScale))
      const height = Math.max(1, Math.round(texture.height * args.tileableScale))
      ctx.globalCompositeOperation = "source-atop"
      const uvScaleW = canvas.width / 16
      const uvScaleH = canvas.height / 16
      await getFontCharacters(args.font)
      for (const [i, char] of Object.values(fonts[args.font].characters).entries()) {
        let faceUV, topUV, bottomUV
        for (const cube of char) {
          for (const face of Object.values(cube.faces)) {
            const mapped = (face?.uv ?? face).map((e, i) => i % 2 ? e * uvScaleH : e * uvScaleW)
            const middle = fonts[args.font].faces.find(e => mapped[1] >= e[0] * res && mapped[1] <= e[e.length - 1] * res && mapped[3] >= e[0] * res && mapped[3] <= e[e.length - 1] * res)
            if (middle) {
              if (!faceUV) {
                faceUV = [Math.min(mapped[0], mapped[2]), middle[0] * res, Math.max(mapped[0], mapped[2]), middle[middle.length - 1] * res, middle.length === 4 ? (middle[1] - middle[0]) * res : null]
              } else {
                faceUV[0] = Math.min(faceUV[0], mapped[0], mapped[2])
                faceUV[2] = Math.max(faceUV[2], mapped[0], mapped[2])
              }
            } else {
              const top = fonts[args.font].ends.find(e => mapped[1] >= e[0] * res && mapped[1] <= e[1] * res && mapped[3] >= e[0] * res && mapped[3] <= e[1] * res)
              if (top) {
                if (!topUV) {
                  topUV = [Math.min(mapped[0], mapped[2]), top[0] * res, Math.max(mapped[0], mapped[2]), top[1] * res]
                } else {
                  topUV[0] = Math.min(topUV[0], mapped[0], mapped[2])
                  topUV[2] = Math.max(topUV[2], mapped[0], mapped[2])
                }
              } else {
                const bottom = fonts[args.font].ends.find(e => mapped[1] >= e[2] * res && mapped[1] <= e[3] * res && mapped[3] >= e[2] * res && mapped[3] <= e[3] * res)
                if (bottom) {
                  if (!bottomUV) {
                    bottomUV = [Math.min(mapped[0], mapped[2]), bottom[2] * res, Math.max(mapped[0], mapped[2]), bottom[3] * res]
                  } else {
                    bottomUV[0] = Math.min(bottomUV[0], mapped[0], mapped[2])
                    bottomUV[2] = Math.max(bottomUV[2], mapped[0], mapped[2])
                  }
                }
              }
            }
          }
        }
        if (faceUV) {
          const area = new CanvasFrame(faceUV[2] - faceUV[0], faceUV[3] - faceUV[1])
          area.ctx.imageSmoothingEnabled = false
          const start = faceUV[4] ?? 0
          for (let y = start; y < area.height; y += height) {
            for (let x = 0; x < area.width; x += width) {
              if (args.tileableRandomRotations || args.tileableRandomMirroring) {
                drawRotatedMirrored(area.ctx, texture, x, y, width, height, Math.floor(random(i, x, y) * 4) * 90 * args.tileableRandomRotations, random(i + 400, x, y) < 0.5 && args.tileableRandomMirroring)
              } else {
                area.ctx.drawImage(texture, x, y, width, height)
              }
            }
          }
          if (start !== 0) {
            for (let y = start; y > 0; y -= height) {
              for (let x = 0; x < area.width; x += width) {
                if (args.tileableRandomRotations || args.tileableRandomMirroring) {
                  drawRotatedMirrored(area.ctx, texture, x, y - height, width, height, Math.floor(random(i + 100, x, y) * 4) * 90 * args.tileableRandomRotations, random(i + 400, x, y) < 0.5 && args.tileableRandomMirroring)
                } else {
                  area.ctx.drawImage(texture, x, y - height, width, height)
                }
              }
            }
          }
          ctx.fillStyle = "#fff"
          ctx.fillRect(faceUV[0], faceUV[1], area.width, area.height)
          ctx.drawImage(area.canvas, faceUV[0], faceUV[1])
        }
        if (topUV) {
          const area = new CanvasFrame(topUV[2] - topUV[0], topUV[3] - topUV[1])
          area.ctx.imageSmoothingEnabled = false
          for (let y = area.height; y > 0; y -= height) {
            for (let x = 0; x < area.width; x += width) {
              if (args.tileableRandomRotations || args.tileableRandomMirroring) {
                drawRotatedMirrored(area.ctx, texture, x, y - height, width, height, Math.floor(random(i + 200, x, y) * 4) * 90 * args.tileableRandomRotations, random(i + 400, x, y) < 0.5 && args.tileableRandomMirroring)
              } else {
                area.ctx.drawImage(texture, x, y - height, width, height)
              }
            }
          }
          ctx.fillStyle = "#fff"
          ctx.fillRect(topUV[0], topUV[1], area.width, area.height)
          ctx.drawImage(area.canvas, topUV[0], topUV[1])
          ctx.fillStyle = `rgba(0, 0, 0, ${(100 - args.edgeBrightness) / 100})`
          ctx.fillRect(topUV[0], topUV[1], area.width, area.height)
        }
        if (bottomUV) {
          const area = new CanvasFrame(bottomUV[2] - bottomUV[0], bottomUV[3] - bottomUV[1])
          area.ctx.imageSmoothingEnabled = false
          for (let y = 0; y < area.height; y += height) {
            for (let x = 0; x < area.width; x += width) {
              if (args.tileableRandomRotations || args.tileableRandomMirroring) {
                drawRotatedMirrored(area.ctx, texture, x, y, width, height, Math.floor(random(i + 300, x, y) * 4) * 90 * args.tileableRandomRotations, random(i + 400, x, y) < 0.5 && args.tileableRandomMirroring)
              } else {
                area.ctx.drawImage(texture, x, y, width, height)
              }
            }
          }
          ctx.fillStyle = "#fff"
          ctx.fillRect(bottomUV[0], bottomUV[1], area.width, area.height)
          ctx.drawImage(area.canvas, bottomUV[0], bottomUV[1])
          ctx.fillStyle = `rgba(0, 0, 0, ${(100 - args.edgeBrightness) / 100})`
          ctx.fillRect(bottomUV[0], bottomUV[1], area.width, area.height)
        }
      }
      if (fonts[args.font].overlay) {
        ctx.globalCompositeOperation = "destination-out"
        await loadOverlay(args.font)
        ctx.drawImage(fonts[args.font].overlay, 0, 0, canvas.width, canvas.height)
        ctx.globalCompositeOperation = "destination-over"
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
      }
    }
    ctx.globalCompositeOperation = "copy"
    ctx.filter =`hue-rotate(${args.hue}deg) saturate(${args.saturation}%) brightness(${args.brightness}%) contrast(${args.contrast}%`
    ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height)
    ctx.filter ="hue-rotate(0deg) saturate(100%) brightness(100%) contrast(100%)"
    ctx.globalCompositeOperation = args.blend
    ctx.fillStyle = args.colour
    ctx.globalAlpha = args.colourOpacity / 100
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    ctx.globalAlpha = 1
    ctx.globalCompositeOperation = "destination-in"
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
    if (args.customEdge) {
      ctx.globalCompositeOperation = "source-atop"
      ctx.fillStyle = args.customEdgeColour
      for (const row of fonts[args.font].ends) {
        ctx.fillRect(0, row[0] * m, canvas.width, (row[1] - row[0]) * m)
        ctx.fillRect(0, row[2] * m, canvas.width, (row[3] - row[2]) * m)
      }
    }
    if (args.customOverlay || (args.overlay && args.overlay !== "none")) {
      const overlay = await loadImage(args.customOverlay ?? await getTexture(fonts[args.font].overlays, args.overlay))
      const overlayCanvas = new CanvasFrame(overlay.width, overlay.height)
      overlayCanvas.ctx.drawImage(overlay, 0, 0)
      overlayCanvas.ctx.globalCompositeOperation = args.overlayColourBlend
      overlayCanvas.ctx.fillStyle = args.overlayColour
      overlayCanvas.ctx.fillRect(0, 0, overlay.width, overlay.height)
      overlayCanvas.ctx.globalCompositeOperation = "destination-in"
      overlayCanvas.ctx.drawImage(overlay, 0, 0)
      if (overlay.width > canvas.width) {
        const frame = new CanvasFrame(overlay.width, overlay.height)
        frame.ctx.imageSmoothingEnabled = false
        frame.ctx.drawImage(canvas, 0, 0, overlay.width, overlay.height)
        canvas = frame.canvas
        ctx = frame.ctx
        m = canvas.width / 1000
      }
      ctx.globalCompositeOperation = args.overlayBlend
      ctx.imageSmoothingEnabled = false
      ctx.globalAlpha = args.overlayOpacity / 100
      ctx.drawImage(overlayCanvas.canvas, 0, 0, canvas.width, canvas.height)
      ctx.globalAlpha = 1
    }
    if (args.customBorder) {
      ctx.globalCompositeOperation = "source-atop"
      ctx.fillStyle = args.customBorderColour
      ctx.fillRect(0, fonts[args.font].border * m, canvas.width, canvas.height - fonts[args.font].border * m)
    }
    if (args.fadeToBorder) {
      ctx.globalCompositeOperation = "source-atop"
      const height = fonts[args.font].ends[fonts[args.font].ends.length - 1][3]
      const border = ctx.getImageData(0, fonts[args.font].border * m, 1, 1).data
      const gradient = ctx.createLinearGradient(0, 0, 0, height * m)
      for (const stop of fonts[args.font].ends) {
        gradient.addColorStop(stop[0] / height, `rgb(${border[0]},${border[1]},${border[2]})`)
        gradient.addColorStop(stop[1] / height, `rgb(${border[0]},${border[1]},${border[2]}, 0)`)
        gradient.addColorStop(stop[2] / height, `rgb(${border[0]},${border[1]},${border[2]}, 0)`)
        gradient.addColorStop(stop[3] / height, `rgb(${border[0]},${border[1]},${border[2]})`)
      }
      ctx.fillStyle = gradient
      ctx.fillRect(0, 0, canvas.width * m, height * m)
    }
    if (args.canvas) return canvas
    if (args.three) {
      const texture = await new Promise(fulfil => new THREE.TextureLoader().load(canvas.toDataURL(), fulfil))
      texture.colorSpace = THREE.SRGBColorSpace
      texture.magFilter = THREE.NearestFilter
      return texture
    }
    return new Texture({
      name: `${args.name ?? makeName(args.text)}.png`,
      render_sides: "front"
    }).fromDataURL(canvas.toDataURL())
  }

  function makeWord(text, offset, parent, args) {
    const word = new Group(args.name ?? makeName(text))
    word.addTo(parent).init()
    for (const char of text) {
      if (fonts[args.font].characters[char]) {
        const [character, width] = makeCharacter(char, offset, word, args)
        offset += width
      }
    }
    if (fonts[args.font].autoBorder) {
      offset += 4
      let minX = Infinity
      let minY = Infinity
      let minZ = Infinity
      let maxX = -Infinity
      let maxY = -Infinity
      let maxZ = -Infinity
      for (const group of word.children) for (const cube of group.children) {
        minX = Math.min(minX, cube.from[0], cube.to[0])
        minY = Math.min(minY, cube.from[1], cube.to[1])
        minZ = Math.min(minZ, cube.from[2], cube.to[2])
        maxX = Math.max(maxX, cube.from[0], cube.to[0])
        maxY = Math.max(maxY, cube.from[1], cube.to[1])
        maxZ = Math.max(maxZ, cube.from[2], cube.to[2])
      }
      const size = 2 * (args.scale[0] + args.scale[1]) / 2 * (args.type === "bottom" ? 0.75 : args.type === "small" ? 0.35 : 1)
      const border = new Cube({
        name: "border",
        from: [maxX + size, maxY + size, maxZ + size],
        to: [minX - size, minY - size, minZ - size]
      })
      const uv = [0, fonts[args.font].border, 1, fonts[args.font].border + 1]
      for (const face of Object.values(border.faces)) {
        face.texture = args.texture
        face.uv = uv
      }
      border.addTo(word).init()
      args.elements.push(border)
    }
    return [word, offset]
  }

  const charMap = {
    "â”«": "open_terminator",
    "â”£": "close_terminator",
    " ": "space",
    "â€‹": "spacer"
  }

  function makeCharacter(char, offset, parent, args) {
    let minX = Infinity
    let maxX = -Infinity
    let minZ = Infinity
    let maxZ = -Infinity
    const cubes = []
    for (const element of fonts[args.font].characters[char]) {
      if (!element.parsed) {
        element.parsed = true
        for (const [direction, uv] of Object.entries(element.faces)) {
          element.faces[direction] = { uv }
        }
      }
      const cube = new Cube(element)
      if (char === "â€‹") {
        if (cube.to[0] > cube.from[0]) {
          cube.to[0] += args.spacerWidth
        } else {
          cube.from[0] += args.spacerWidth
        }
      }
      if (args.type === "small") {
        if (cube.to[2] > cube.from[2]) {
          cube.to[2] -= 6
        } else {
          cube.from[2] -= 6
        }
      }
      minX = Math.min(minX, cube.from[0], cube.to[0])
      maxX = Math.max(maxX, cube.from[0], cube.to[0])
      minZ = Math.min(minZ, cube.from[2], cube.to[2])
      maxZ = Math.max(maxZ, cube.from[2], cube.to[2])
      cube.autouv = 0
      for (const key in cube.faces) {
        const readFace = element.faces[key]
        const newFace = cube.faces[key]
        if (readFace === undefined) {
          newFace.texture = null
          newFace.uv = [0, 0, 0, 0]
        } else {
          newFace.texture = args.texture
          newFace.uv.forEach((n, i) => {
            newFace.uv[i] = readFace.uv[i] * UVEditor.getResolution(i % 2) / 16
          })
        }
      }
      cubes.push(cube)
    }
    const character = new Group(charMap[char] ? charMap[char] : makeName(char))
    character.addTo(parent).init()
    const heightOffset = fonts[args.font].height
    for (const cube of cubes) {
      cube.to[0] -= offset + maxX
      cube.from[0] -= offset + maxX
      cube.to[2] -= minZ
      cube.from[2] -= minZ
      if (args.type === "bottom") {
        cube.to[1] *= 2
        cube.from[1] *= 2
        cube.to[1] -= args.row * (heightOffset * 2 + 4) + args.rowSpacing * args.row + heightOffset * 2 + 18
        cube.from[1] -= args.row * (heightOffset * 2 + 4) + args.rowSpacing * args.row + heightOffset * 2 + 18
        cube.to = cube.to.map(e => e * 0.75)
        cube.from = cube.from.map(e => e * 0.75)
        cube.to[2] -= 8
        cube.from[2] -= 8
        if (!fonts[args.font].flat) {
          if (cube.to[2] > cube.from[2]) {
            cube.to[2] += 24
          } else {
            cube.from[2] += 24
          }
        }
      } else if (args.type === "small") {
        cube.to[2] -= (maxZ - minZ)
        cube.from[2] -= (maxZ - minZ)
        cube.to[0] *= 0.35
        cube.from[0] *= 0.35
        cube.to[1] *= 0.35
        cube.from[1] *= 0.35
        cube.to[2] *= 0.35
        cube.from[2] *= 0.35
        cube.to[1] -= args.row * (heightOffset * 0.35) + args.rowSpacing * args.row + heightOffset * 0.35
        cube.from[1] -= args.row * (heightOffset * 0.35) + args.rowSpacing * args.row + heightOffset * 0.35
      } else {
        cube.to[2] -= (maxZ - minZ) / 2
        cube.from[2] -= (maxZ - minZ) / 2
        cube.to[1] += args.row * (heightOffset + 4) + args.rowSpacing * args.row
        cube.from[1] += args.row * (heightOffset + 4) + args.rowSpacing * args.row
      }
      cube.to = cube.to.map((e, i) => e * args.scale[i])
      cube.from = cube.from.map((e, i) => e * args.scale[i])
      cube.addTo(character).init()
      args.elements.push(cube)
    }
    return [character, maxX - minX + args.characterSpacing * args.scale[0]]
  }

  const makeName = str => str.replace(/\s/g, "_").replace(/ðŸ˜³/g, "a").replace(/ðŸ˜©/g, "'").replace(/â”«|â”£|\u200b/g, "")

  function selectHandler() {
    if (Mode.selected.id === "minecraft_title_render") Canvas.scene.traverseVisible(e => {
      if (e.type === "Line") e.visible = false
    })
  }

  async function getFontTextures(font, force) {
    if (typeof fonts[font].textures === "object") {
      if (!force) return
    } else {
      fonts[font].textures = {}
    }
    if (!fonts[font].overlays?.none) fonts[font].overlays = { none: { name: "None" } }
    const data = await fetchData(`fonts/${font}/textures.json`, () => ({ textures: {}, overlays: {} }))
    for (const [id, texture] of Object.entries(data.textures)) {
      texture.name ??= titleCase(id)
      texture.texture = `fonts/${font}/textures/${id}.png`
      if (texture.variants) for (const [id, variant] of Object.entries(texture.variants)) {
        variant.name ??= titleCase(id)
        variant.texture = `fonts/${font}/textures/${id}.png`
      }
      fonts[font].textures[id] = texture
    }
    for (const [id, overlay] of Object.entries(data.overlays)) {
      overlay.name ??= titleCase(id)
      overlay.texture = `fonts/${font}/overlays/${id}.png`
      fonts[font].overlays[id] = overlay
    }
    const flat = stats.find(e => e.id === `${font}.flat`)
    if (flat) flat.count = Infinity
    else stats.push({
      id: `${font}.flat`,
      count: Infinity
    })
    stats.push({
      id: `${font}.none`,
      count: Infinity
    })
    const mainId = Object.keys(fonts[font].textures)[1]
    if (mainId) {
      const main = stats.find(e => e.id === `${font}.${mainId}`)
      if (main) main.count = 999999999
      else stats.push({
        id: `${font}.${mainId}`,
        count: 999999999
      })
    }
  }

  async function getFontCharacters(id) {
    if (typeof fonts[id].characters === "object") return
    fonts[id].characters = await fetchData(`fonts/${id}/characters.json`)
  }

  function titleCase(str) {
    return str.replace(/_|-/g, " ").replace(/\w\S*/g, str => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase())
  }

  function updateColour(dialog, v, c) {
    dialog.component.data[v] = c.toHexString()
    dialog.content_vue.updatePreview()
  }

  const colourInput = (dialog, v) => ({
    preferredFormat: "hex",
    color: dialog.component.data[v],
    showAlpha: false,
    showInput: true,
    move: c => updateColour(dialog, v, c),
    change: c => updateColour(dialog, v, c),
    hide: c => updateColour(dialog, v, c)
  })

  async function getTextureFromFile() {
    try {
      let texture
      if (isApp) {
        const file = electron.dialog.showOpenDialogSync({
          filters: [{
            name: "PNG Texture",
            extensions: ["png"]
          }]
        })
        if (!file) return
        texture = await loadImage(file[0])
      } else {
        const input = document.createElement("input")
        let file
        input.type = "file"
        input.accept = ".png"
        await new Promise(fulfil => {
          input.onchange = () => {
            file = Array.from(input.files)
            fulfil()
          }
          input.click()
        })
        const data = await new Promise(fulfil => {
          const fr = new FileReader()
          fr.onload = () => fulfil(fr.result)
          fr.readAsDataURL(file[0])
        })
        texture = await loadImage(data)
      }
      return texture
    } catch {
      Blockbench.showQuickMessage("Unable to load texture")
    }
  }

  const getArgs = (vue, three) => ({
    font: vue.font,
    type: vue.textType,
    row: vue.row,
    texture: vue.textureSource === "gradient" || vue.textureSource === "tileable" || (vue.textureSource === "file" && vue.customTexture) || (!vue.customTexture && vue.textureSource === "file" && ["gradient", "tileable"].includes(vue.lastTextureSource)) ? "flat" : vue.texture,
    variant: vue.textureSource === "premade" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "premade") ? vue.variant : null,
    tileable: vue.textureSource === "tileable" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "tileable") ? vue.tileable : null,
    tileableVariant: vue.textureSource === "tileable" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "tileable") ? vue.tileableVariant : null,
    characterSpacing: vue.characterSpacing,
    rowSpacing: vue.rowSpacing,
    scale: [vue.scaleX, vue.scaleY, vue.scaleZ],
    colour: vue.colour,
    blend: vue.blend,
    hue: vue.hue,
    saturation: vue.saturation,
    brightness: vue.brightness,
    contrast: vue.contrast,
    customBorder: vue.customBorder,
    customBorderColour: vue.customBorderColour,
    fadeToBorder: vue.fadeToBorder,
    terminators: vue.terminators,
    customEdge: vue.customEdge,
    customEdgeColour: vue.customEdgeColour,
    customTexture: vue.textureSource === "file" ? vue.customTexture : null,
    customTextureType: vue.customTextureType,
    customOverlay: vue.overlaySource === "file" ? vue.customOverlay : null,
    gradientColour0: (vue.textureSource === "gradient" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "gradient")) ? vue.gradientColour0 : null,
    gradientColour1: (vue.textureSource === "gradient" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "gradient")) && vue.gradientColour1Enabled ? vue.gradientColour1 : null,
    gradientColour2: (vue.textureSource === "gradient" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "gradient")) && vue.gradientColour2Enabled ? vue.gradientColour2 : null,
    gradientColour3: (vue.textureSource === "gradient" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "gradient")) && vue.gradientColour3Enabled ? vue.gradientColour3 : null,
    gradientColour4: (vue.textureSource === "gradient" || (!vue.customTexture && vue.textureSource === "file" && vue.lastTextureSource === "gradient")) ? vue.gradientColour4 : null,
    overlay: vue.overlay,
    overlayBlend: vue.overlayBlend,
    overlayColourBlend: vue.overlayColourBlend,
    overlayColour: vue.overlayColour,
    smoothGradient: vue.smoothGradient,
    colourOpacity: vue.colourOpacity,
    overlayOpacity: vue.overlayOpacity,
    tileableScale: vue.tileableScale,
    tileableXOffset: vue.tileableXOffset,
    tileableYOffset: vue.tileableYOffset,
    tileableRandomRotations: vue.tileableRandomRotations,
    tileableRandomMirroring: vue.tileableRandomMirroring,
    tileableTextureResolution: vue.tileableTextureResolution,
    edgeBrightness: vue.edgeBrightness,
    three
  })

  function areObjectsEqual(obj1, obj2) {
    const keys1 = Object.keys(obj1)
    const keys2 = Object.keys(obj2)
    if (keys1.length !== keys2.length) return false
    for (let key of keys1) if (!obj2.hasOwnProperty(key) || obj1[key].toString() !== obj2[key].toString()) return false
    return true
  }

  function loadImage(b64) {
    const img = new Image()
    return new Promise((fulfil, reject) => {
      img.onload = () => fulfil(img)
      img.onerror = reject
      img.src = b64
    })
  }

  function loadRenderAngle() {
    Preview.selected.loadAnglePreset({
      position: [0, -170, -320],
      target: [0, 0, 0]
    })
  }

  const gcd = (a, b) => b === 0 ? a : gcd(b, a % b)

  function getAspectRatio(w, h) {
    const divisor = gcd(w, h)
    return [w / divisor, h / divisor]
  }

  function getFromAspect(aW, aH, w, h, isWidth) {
    let width, height
    if (isWidth) {
      width = w
      height = Math.floor(w * aH / aW)
      if (height > 4096) {
        height = 4096
        width = Math.floor(4096 * aW / aH)
      }
    } else {
      height = h
      width = Math.floor(h * aW / aH)
      if (width > 4096) {
        width = 4096
        height = Math.floor(4096 * aH / aW)
      }
    }
    return [width, height]
  }

  async function getTileable(id, variant) {
    const data = variant ? tileables[id].variants[variant] : tileables[id]
    if (!data.texture) {
      data.texture = await new Promise(async fulfil => {
        const reader = new FileReader()
        reader.onload = e => fulfil(e.target.result)
        reader.readAsDataURL(new Blob([await fetchData(`/tileables/${data.path ? data.path + "/" : ""}${variant ?? id}.png`).then(e => e.arrayBuffer())], { type: "image/png" }))
      }).catch(() => {})
    }
    return data.texture
  }

  async function loadOverlay(id) {
    if (typeof fonts[id].overlay === "boolean") {
      fonts[id].overlay = await loadImage(await getTexture(null, null, null, `fonts/${id}/textures/overlay.png`))
    }
  }

  function drawRotatedMirrored(ctx, img, x, y, w, h, r, mirror) {
    ctx.save()
    ctx.translate(x + w / 2, y + h / 2)
    ctx.rotate(Math.degToRad(r))
    if (mirror) ctx.scale(-1, 1)
    ctx.drawImage(img, -(w / 2), -(h / 2), w, h)
    ctx.restore()
  }

  const fract = n => n - Math.floor(n)

  function random(x, y, z) {
    x = fract(x * 0.1031)
    y = fract(y * 0.1031)
    z = fract(z * 0.1031)
    const res = x * (z + 31.32) + y * (y + 31.32) + z * (x + 31.32)
    return fract((x + y + res * 2) * (z + res))
  }
})()
